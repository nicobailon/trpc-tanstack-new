import {
  TRPCUntypedClient,
  callProcedure,
  createRecursiveProxy,
  getUntypedClient,
  isAsyncIterable,
  isFunction,
  isObject
} from "./chunk-EDPMR3SK.js";
import {
  hashKey,
  infiniteQueryOptions,
  queryOptions,
  skipToken
} from "./chunk-B4AGHTBX.js";
import "./chunk-I7TO7CYR.js";
import {
  require_react
} from "./chunk-CEHRAWMB.js";
import {
  __toESM
} from "./chunk-QWN5BXRD.js";

// node_modules/@trpc/tanstack-react-query/dist/internals/Context.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@trpc/tanstack-react-query/dist/internals/utils.mjs
function createTRPCOptionsResult(value) {
  const path = value.path.join(".");
  return {
    path
  };
}
function getClientArgs(queryKey, opts, infiniteParams) {
  var _a;
  const path = queryKey[0];
  let input = (_a = queryKey[1]) == null ? void 0 : _a.input;
  if (infiniteParams) {
    input = {
      ...input ?? {},
      ...infiniteParams.pageParam !== void 0 ? {
        cursor: infiniteParams.pageParam
      } : {},
      direction: infiniteParams.direction
    };
  }
  return [
    path.join("."),
    input,
    opts == null ? void 0 : opts.trpc
  ];
}
async function buildQueryFromAsyncIterable(asyncIterable, queryClient, queryKey) {
  const queryCache = queryClient.getQueryCache();
  const query = queryCache.build(queryClient, {
    queryKey
  });
  query.setState({
    data: [],
    status: "success"
  });
  const aggregate = [];
  for await (const value of asyncIterable) {
    aggregate.push(value);
    query.setState({
      data: [
        ...aggregate
      ]
    });
  }
  return aggregate;
}
function getQueryKeyInternal(path, input, type) {
  const splitPath = path.flatMap((part) => part.split("."));
  if (!input && (!type || type === "any")) {
    return splitPath.length ? [
      splitPath
    ] : [];
  }
  if (type === "infinite" && isObject(input) && ("direction" in input || "cursor" in input)) {
    const { cursor: _, direction: __, ...inputWithoutCursorAndDirection } = input;
    return [
      splitPath,
      {
        input: inputWithoutCursorAndDirection,
        type: "infinite"
      }
    ];
  }
  return [
    splitPath,
    {
      ...typeof input !== "undefined" && input !== skipToken && {
        input
      },
      ...type && type !== "any" && {
        type
      }
    }
  ];
}
function getMutationKeyInternal(path) {
  const splitPath = path.flatMap((part) => part.split("."));
  return splitPath.length ? [
    splitPath
  ] : [];
}
function unwrapLazyArg(valueOrLazy) {
  return isFunction(valueOrLazy) ? valueOrLazy() : valueOrLazy;
}

// node_modules/@trpc/tanstack-react-query/dist/internals/infiniteQueryOptions.mjs
function trpcInfiniteQueryOptions(args) {
  const { input, query, path, queryKey, opts } = args;
  const inputIsSkipToken = input === skipToken;
  const queryFn = async (queryFnContext) => {
    var _a;
    const actualOpts = {
      ...opts,
      trpc: {
        ...opts == null ? void 0 : opts.trpc,
        ...((_a = opts == null ? void 0 : opts.trpc) == null ? void 0 : _a.abortOnUnmount) ? {
          signal: queryFnContext.signal
        } : {
          signal: null
        }
      }
    };
    const result = await query(...getClientArgs(queryKey, actualOpts, {
      direction: queryFnContext.direction,
      pageParam: queryFnContext.pageParam
    }));
    return result;
  };
  return Object.assign(infiniteQueryOptions({
    ...opts,
    queryKey,
    queryFn: inputIsSkipToken ? skipToken : queryFn,
    initialPageParam: (opts == null ? void 0 : opts.initialCursor) ?? (input == null ? void 0 : input.cursor)
  }), {
    trpc: createTRPCOptionsResult({
      path
    })
  });
}

// node_modules/@trpc/tanstack-react-query/dist/internals/mutationOptions.mjs
function trpcMutationOptions(args) {
  const { mutate, path, opts, overrides } = args;
  const queryClient = unwrapLazyArg(args.queryClient);
  const mutationKey = getMutationKeyInternal(path);
  const defaultOpts = queryClient.defaultMutationOptions(queryClient.getMutationDefaults(mutationKey));
  const mutationSuccessOverride = (overrides == null ? void 0 : overrides.onSuccess) ?? ((options) => options.originalFn());
  const mutationFn = async (input) => {
    const result = await mutate(...getClientArgs([
      path,
      {
        input
      }
    ], opts));
    return result;
  };
  return {
    ...opts,
    mutationKey,
    mutationFn,
    onSuccess(...args2) {
      const originalFn = () => {
        var _a, _b;
        return ((_a = opts == null ? void 0 : opts.onSuccess) == null ? void 0 : _a.call(opts, ...args2)) ?? ((_b = defaultOpts == null ? void 0 : defaultOpts.onSuccess) == null ? void 0 : _b.call(defaultOpts, ...args2));
      };
      return mutationSuccessOverride({
        originalFn,
        queryClient,
        meta: (opts == null ? void 0 : opts.meta) ?? (defaultOpts == null ? void 0 : defaultOpts.meta) ?? {}
      });
    },
    trpc: createTRPCOptionsResult({
      path
    })
  };
}

// node_modules/@trpc/tanstack-react-query/dist/internals/queryOptions.mjs
function trpcQueryOptions(args) {
  const { input, query, path, queryKey, opts } = args;
  const queryClient = unwrapLazyArg(args.queryClient);
  const inputIsSkipToken = input === skipToken;
  const queryFn = async (queryFnContext) => {
    var _a;
    const actualOpts = {
      ...opts,
      trpc: {
        ...opts == null ? void 0 : opts.trpc,
        ...((_a = opts == null ? void 0 : opts.trpc) == null ? void 0 : _a.abortOnUnmount) ? {
          signal: queryFnContext.signal
        } : {
          signal: null
        }
      }
    };
    const result = await query(...getClientArgs(queryKey, actualOpts));
    if (isAsyncIterable(result)) {
      return buildQueryFromAsyncIterable(result, queryClient, queryKey);
    }
    return result;
  };
  return Object.assign(queryOptions({
    ...opts,
    queryKey,
    queryFn: inputIsSkipToken ? skipToken : queryFn
  }), {
    trpc: createTRPCOptionsResult({
      path
    })
  });
}

// node_modules/@trpc/tanstack-react-query/dist/internals/subscriptionOptions.mjs
var React = __toESM(require_react(), 1);
var trpcSubscriptionOptions = (args) => {
  var _a;
  const { subscribe, path, queryKey, opts } = args;
  const input = (_a = queryKey[1]) == null ? void 0 : _a.input;
  const enabled = "enabled" in opts ? !!opts.enabled : input !== skipToken;
  const _subscribe = (innerOpts) => {
    return subscribe(path.join("."), input ?? void 0, innerOpts);
  };
  return {
    ...opts,
    enabled,
    subscribe: _subscribe,
    queryKey,
    trpc: createTRPCOptionsResult({
      path
    })
  };
};
function useSubscription(opts) {
  const optsRef = React.useRef(opts);
  optsRef.current = opts;
  const trackedProps = React.useRef(/* @__PURE__ */ new Set([]));
  const addTrackedProp = React.useCallback((key) => {
    trackedProps.current.add(key);
  }, []);
  const currentSubscriptionRef = React.useRef(() => {
  });
  const reset = React.useCallback(() => {
    var _a;
    (_a = currentSubscriptionRef.current) == null ? void 0 : _a.call(currentSubscriptionRef);
    updateState(getInitialState);
    if (!opts.enabled) {
      return;
    }
    const subscription = opts.subscribe({
      onStarted: () => {
        var _a2, _b;
        (_b = (_a2 = optsRef.current).onStarted) == null ? void 0 : _b.call(_a2);
        updateState((prev) => ({
          ...prev,
          status: "pending",
          error: null
        }));
      },
      onData: (data) => {
        var _a2, _b;
        (_b = (_a2 = optsRef.current).onData) == null ? void 0 : _b.call(_a2, data);
        updateState((prev) => ({
          ...prev,
          status: "pending",
          data,
          error: null
        }));
      },
      onError: (error) => {
        var _a2, _b;
        (_b = (_a2 = optsRef.current).onError) == null ? void 0 : _b.call(_a2, error);
        updateState((prev) => ({
          ...prev,
          status: "error",
          error
        }));
      },
      onConnectionStateChange: (result) => {
        updateState((prev) => {
          switch (result.state) {
            case "connecting":
              return {
                ...prev,
                status: "connecting",
                error: result.error
              };
            case "pending":
              return prev;
            case "idle":
              return {
                ...prev,
                status: "idle",
                data: void 0,
                error: null
              };
          }
        });
      }
    });
    currentSubscriptionRef.current = () => {
      subscription.unsubscribe();
    };
  }, [
    hashKey(opts.queryKey),
    opts.enabled
  ]);
  const getInitialState = React.useCallback(() => {
    return opts.enabled ? {
      data: void 0,
      error: null,
      status: "connecting",
      reset
    } : {
      data: void 0,
      error: null,
      status: "idle",
      reset
    };
  }, [
    opts.enabled,
    reset
  ]);
  const resultRef = React.useRef(getInitialState());
  const [state, setState] = React.useState(trackResult(resultRef.current, addTrackedProp));
  state.reset = reset;
  const updateState = React.useCallback((callback) => {
    const prev = resultRef.current;
    const next = resultRef.current = callback(prev);
    let shouldUpdate = false;
    for (const key of trackedProps.current) {
      if (prev[key] !== next[key]) {
        shouldUpdate = true;
        break;
      }
    }
    if (shouldUpdate) {
      setState(trackResult(next, addTrackedProp));
    }
  }, [
    addTrackedProp
  ]);
  React.useEffect(() => {
    if (!opts.enabled) {
      return;
    }
    reset();
    return () => {
      var _a;
      (_a = currentSubscriptionRef.current) == null ? void 0 : _a.call(currentSubscriptionRef);
    };
  }, [
    reset,
    opts.enabled
  ]);
  return state;
}
function trackResult(result, onTrackResult) {
  const trackedResult = new Proxy(result, {
    get(target, prop) {
      onTrackResult(prop);
      return target[prop];
    }
  });
  return trackedResult;
}

// node_modules/@trpc/tanstack-react-query/dist/internals/createOptionsProxy.mjs
function createTRPCOptionsProxy(opts) {
  const callIt = (type) => {
    return (path, input, trpcOpts) => {
      if ("router" in opts) {
        return Promise.resolve(unwrapLazyArg(opts.ctx)).then((ctx) => callProcedure({
          router: opts.router,
          path,
          getRawInput: async () => input,
          ctx,
          type,
          signal: void 0
        }));
      }
      const untypedClient = opts.client instanceof TRPCUntypedClient ? opts.client : getUntypedClient(opts.client);
      return untypedClient[type](path, input, trpcOpts);
    };
  };
  return createRecursiveProxy(({ args, path: _path }) => {
    const path = [
      ..._path
    ];
    const utilName = path.pop();
    const [arg1, arg2] = args;
    const contextMap = {
      "~types": void 0,
      pathKey: () => {
        return getQueryKeyInternal(path);
      },
      pathFilter: () => {
        return {
          ...arg1,
          queryKey: getQueryKeyInternal(path)
        };
      },
      queryOptions: () => {
        return trpcQueryOptions({
          input: arg1,
          opts: arg2,
          path,
          queryClient: opts.queryClient,
          queryKey: getQueryKeyInternal(path, arg1, "query"),
          query: callIt("query")
        });
      },
      queryKey: () => {
        return getQueryKeyInternal(path, arg1, "query");
      },
      queryFilter: () => {
        return {
          ...arg2,
          queryKey: getQueryKeyInternal(path, arg1, "query")
        };
      },
      infiniteQueryOptions: () => {
        return trpcInfiniteQueryOptions({
          input: arg1,
          opts: arg2,
          path,
          queryClient: opts.queryClient,
          queryKey: getQueryKeyInternal(path, arg1, "infinite"),
          query: callIt("query")
        });
      },
      infiniteQueryKey: () => {
        return getQueryKeyInternal(path, arg1, "infinite");
      },
      infiniteQueryFilter: () => {
        return {
          ...arg2,
          queryKey: getQueryKeyInternal(path, arg1, "infinite")
        };
      },
      mutationOptions: () => {
        var _a;
        return trpcMutationOptions({
          opts: arg1,
          path,
          queryClient: opts.queryClient,
          mutate: callIt("mutation"),
          overrides: (_a = opts.overrides) == null ? void 0 : _a.mutations
        });
      },
      mutationKey: () => {
        return getMutationKeyInternal(path);
      },
      subscriptionOptions: () => {
        return trpcSubscriptionOptions({
          opts: arg2,
          path,
          queryKey: getQueryKeyInternal(path, arg1, "any"),
          subscribe: callIt("subscription")
        });
      }
    };
    return contextMap[utilName]();
  });
}

// node_modules/@trpc/tanstack-react-query/dist/internals/Context.mjs
function createTRPCContext() {
  const TRPCClientContext = React2.createContext(null);
  const TRPCContext = React2.createContext(null);
  function TRPCProvider(props) {
    const value = React2.useMemo(() => createTRPCOptionsProxy({
      client: props.trpcClient,
      queryClient: props.queryClient
    }), [
      props.trpcClient,
      props.queryClient
    ]);
    return React2.createElement(TRPCClientContext.Provider, {
      value: props.trpcClient
    }, React2.createElement(TRPCContext.Provider, {
      value
    }, props.children));
  }
  function useTRPC() {
    const utils = React2.useContext(TRPCContext);
    if (!utils) {
      throw new Error("useTRPC() can only be used inside of a <TRPCProvider>");
    }
    return utils;
  }
  function useTRPCClient() {
    const client = React2.useContext(TRPCClientContext);
    if (!client) {
      throw new Error("useTRPCClient() can only be used inside of a <TRPCProvider>");
    }
    return client;
  }
  return {
    TRPCProvider,
    useTRPC,
    useTRPCClient
  };
}
export {
  createTRPCContext,
  createTRPCOptionsProxy,
  useSubscription
};
//# sourceMappingURL=@trpc_tanstack-react-query.js.map
