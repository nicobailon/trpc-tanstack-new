{
  "version": 3,
  "sources": ["../../../../@trpc/tanstack-react-query/dist/internals/Context.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/utils.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/infiniteQueryOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/mutationOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/queryOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/subscriptionOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/createOptionsProxy.mjs"],
  "sourcesContent": ["import * as React from 'react';\nimport { createTRPCOptionsProxy } from './createOptionsProxy.mjs';\n\n/**\n * Create a set of type-safe provider-consumers\n *\n * @see https://trpc.io/docs/client/tanstack-react-query/setup#3a-setup-the-trpc-context-provider\n */ function createTRPCContext() {\n    const TRPCClientContext = /*#__PURE__*/ React.createContext(null);\n    const TRPCContext = /*#__PURE__*/ React.createContext(null);\n    function TRPCProvider(props) {\n        const value = React.useMemo(()=>createTRPCOptionsProxy({\n                client: props.trpcClient,\n                queryClient: props.queryClient\n            }), [\n            props.trpcClient,\n            props.queryClient\n        ]);\n        return /*#__PURE__*/ React.createElement(TRPCClientContext.Provider, {\n            value: props.trpcClient\n        }, /*#__PURE__*/ React.createElement(TRPCContext.Provider, {\n            value: value\n        }, props.children));\n    }\n    function useTRPC() {\n        const utils = React.useContext(TRPCContext);\n        if (!utils) {\n            throw new Error('useTRPC() can only be used inside of a <TRPCProvider>');\n        }\n        return utils;\n    }\n    function useTRPCClient() {\n        const client = React.useContext(TRPCClientContext);\n        if (!client) {\n            throw new Error('useTRPCClient() can only be used inside of a <TRPCProvider>');\n        }\n        return client;\n    }\n    return {\n        TRPCProvider,\n        useTRPC,\n        useTRPCClient\n    };\n}\n\nexport { createTRPCContext };\n", "import { skipToken } from '@tanstack/react-query';\nimport { isObject, isFunction } from '@trpc/server/unstable-core-do-not-import';\n\n/**\n * @internal\n */ function createTRPCOptionsResult(value) {\n    const path = value.path.join('.');\n    return {\n        path\n    };\n}\n/**\n * @internal\n */ function getClientArgs(queryKey, opts, infiniteParams) {\n    const path = queryKey[0];\n    let input = queryKey[1]?.input;\n    if (infiniteParams) {\n        input = {\n            ...input ?? {},\n            ...infiniteParams.pageParam !== undefined ? {\n                cursor: infiniteParams.pageParam\n            } : {},\n            direction: infiniteParams.direction\n        };\n    }\n    return [\n        path.join('.'),\n        input,\n        opts?.trpc\n    ];\n}\n/**\n * @internal\n */ async function buildQueryFromAsyncIterable(asyncIterable, queryClient, queryKey) {\n    const queryCache = queryClient.getQueryCache();\n    const query = queryCache.build(queryClient, {\n        queryKey\n    });\n    query.setState({\n        data: [],\n        status: 'success'\n    });\n    const aggregate = [];\n    for await (const value of asyncIterable){\n        aggregate.push(value);\n        query.setState({\n            data: [\n                ...aggregate\n            ]\n        });\n    }\n    return aggregate;\n}\n/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query.\n *\n * @internal\n */ function getQueryKeyInternal(path, input, type) {\n    // Construct a query key that is easy to destructure and flexible for\n    // partial selecting etc.\n    // https://github.com/trpc/trpc/issues/3128\n    // some parts of the path may be dot-separated, split them up\n    const splitPath = path.flatMap((part)=>part.split('.'));\n    if (!input && (!type || type === 'any')) {\n        // this matches also all mutations (see `getMutationKeyInternal`)\n        // for `utils.invalidate()` to match all queries (including vanilla react-query)\n        // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n        return splitPath.length ? [\n            splitPath\n        ] : [];\n    }\n    if (type === 'infinite' && isObject(input) && ('direction' in input || 'cursor' in input)) {\n        const { cursor: _, direction: __, ...inputWithoutCursorAndDirection } = input;\n        return [\n            splitPath,\n            {\n                input: inputWithoutCursorAndDirection,\n                type: 'infinite'\n            }\n        ];\n    }\n    return [\n        splitPath,\n        {\n            ...typeof input !== 'undefined' && input !== skipToken && {\n                input: input\n            },\n            ...type && type !== 'any' && {\n                type: type\n            }\n        }\n    ];\n}\n/**\n * @internal\n */ function getMutationKeyInternal(path) {\n    // some parts of the path may be dot-separated, split them up\n    const splitPath = path.flatMap((part)=>part.split('.'));\n    return splitPath.length ? [\n        splitPath\n    ] : [];\n}\n/**\n * @internal\n */ function unwrapLazyArg(valueOrLazy) {\n    return isFunction(valueOrLazy) ? valueOrLazy() : valueOrLazy;\n}\n\nexport { buildQueryFromAsyncIterable, createTRPCOptionsResult, getClientArgs, getMutationKeyInternal, getQueryKeyInternal, unwrapLazyArg };\n", "import { infiniteQueryOptions, skipToken } from '@tanstack/react-query';\nimport { createTRPCOptionsResult, getClientArgs } from './utils.mjs';\n\nfunction trpcInfiniteQueryOptions(args) {\n    const { input, query, path, queryKey, opts } = args;\n    const inputIsSkipToken = input === skipToken;\n    const queryFn = async (queryFnContext)=>{\n        const actualOpts = {\n            ...opts,\n            trpc: {\n                ...opts?.trpc,\n                ...opts?.trpc?.abortOnUnmount ? {\n                    signal: queryFnContext.signal\n                } : {\n                    signal: null\n                }\n            }\n        };\n        const result = await query(...getClientArgs(queryKey, actualOpts, {\n            direction: queryFnContext.direction,\n            pageParam: queryFnContext.pageParam\n        }));\n        return result;\n    };\n    return Object.assign(infiniteQueryOptions({\n        ...opts,\n        queryKey,\n        queryFn: inputIsSkipToken ? skipToken : queryFn,\n        initialPageParam: opts?.initialCursor ?? input?.cursor\n    }), {\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    });\n}\n\nexport { trpcInfiniteQueryOptions };\n", "import { unwrapLazyArg, getMutationKeyInternal, createTRPCOptionsResult, getClientArgs } from './utils.mjs';\n\n/**\n * @internal\n */ function trpcMutationOptions(args) {\n    const { mutate, path, opts, overrides } = args;\n    const queryClient = unwrapLazyArg(args.queryClient);\n    const mutationKey = getMutationKeyInternal(path);\n    const defaultOpts = queryClient.defaultMutationOptions(queryClient.getMutationDefaults(mutationKey));\n    const mutationSuccessOverride = overrides?.onSuccess ?? ((options)=>options.originalFn());\n    const mutationFn = async (input)=>{\n        const result = await mutate(...getClientArgs([\n            path,\n            {\n                input\n            }\n        ], opts));\n        return result;\n    };\n    return {\n        ...opts,\n        mutationKey: mutationKey,\n        mutationFn,\n        onSuccess (...args) {\n            const originalFn = ()=>opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n            return mutationSuccessOverride({\n                originalFn,\n                queryClient,\n                meta: opts?.meta ?? defaultOpts?.meta ?? {}\n            });\n        },\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    };\n}\n\nexport { trpcMutationOptions };\n", "import { queryOptions, skipToken } from '@tanstack/react-query';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport { unwrapLazyArg, createTRPCOptionsResult, getClientArgs, buildQueryFromAsyncIterable } from './utils.mjs';\n\n/**\n * @internal\n */ function trpcQueryOptions(args) {\n    const { input, query, path, queryKey, opts } = args;\n    const queryClient = unwrapLazyArg(args.queryClient);\n    const inputIsSkipToken = input === skipToken;\n    const queryFn = async (queryFnContext)=>{\n        const actualOpts = {\n            ...opts,\n            trpc: {\n                ...opts?.trpc,\n                ...opts?.trpc?.abortOnUnmount ? {\n                    signal: queryFnContext.signal\n                } : {\n                    signal: null\n                }\n            }\n        };\n        const result = await query(...getClientArgs(queryKey, actualOpts));\n        if (isAsyncIterable(result)) {\n            return buildQueryFromAsyncIterable(result, queryClient, queryKey);\n        }\n        return result;\n    };\n    return Object.assign(queryOptions({\n        ...opts,\n        queryKey,\n        queryFn: inputIsSkipToken ? skipToken : queryFn\n    }), {\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    });\n}\n\nexport { trpcQueryOptions };\n", "import { hashKey, skipToken } from '@tanstack/react-query';\nimport * as React from 'react';\nimport { createTRPCOptionsResult } from './utils.mjs';\n\n/**\n * @internal\n */ const trpcSubscriptionOptions = (args)=>{\n    const { subscribe, path, queryKey, opts } = args;\n    const input = queryKey[1]?.input;\n    const enabled = 'enabled' in opts ? !!opts.enabled : input !== skipToken;\n    const _subscribe = (innerOpts)=>{\n        return subscribe(path.join('.'), input ?? undefined, innerOpts);\n    };\n    return {\n        ...opts,\n        enabled,\n        subscribe: _subscribe,\n        queryKey,\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    };\n};\nfunction useSubscription(opts) {\n    const optsRef = React.useRef(opts);\n    optsRef.current = opts;\n    const trackedProps = React.useRef(new Set([]));\n    const addTrackedProp = React.useCallback((key)=>{\n        trackedProps.current.add(key);\n    }, []);\n    const currentSubscriptionRef = React.useRef(()=>{\n    // noop\n    });\n    const reset = React.useCallback(()=>{\n        // unsubscribe from the previous subscription\n        currentSubscriptionRef.current?.();\n        updateState(getInitialState);\n        if (!opts.enabled) {\n            return;\n        }\n        const subscription = opts.subscribe({\n            onStarted: ()=>{\n                optsRef.current.onStarted?.();\n                updateState((prev)=>({\n                        ...prev,\n                        status: 'pending',\n                        error: null\n                    }));\n            },\n            onData: (data)=>{\n                optsRef.current.onData?.(data);\n                updateState((prev)=>({\n                        ...prev,\n                        status: 'pending',\n                        data,\n                        error: null\n                    }));\n            },\n            onError: (error)=>{\n                optsRef.current.onError?.(error);\n                updateState((prev)=>({\n                        ...prev,\n                        status: 'error',\n                        error\n                    }));\n            },\n            onConnectionStateChange: (result)=>{\n                updateState((prev)=>{\n                    switch(result.state){\n                        case 'connecting':\n                            return {\n                                ...prev,\n                                status: 'connecting',\n                                error: result.error\n                            };\n                        case 'pending':\n                            // handled in onStarted\n                            return prev;\n                        case 'idle':\n                            return {\n                                ...prev,\n                                status: 'idle',\n                                data: undefined,\n                                error: null\n                            };\n                    }\n                });\n            }\n        });\n        currentSubscriptionRef.current = ()=>{\n            subscription.unsubscribe();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        hashKey(opts.queryKey),\n        opts.enabled\n    ]);\n    const getInitialState = React.useCallback(()=>{\n        return opts.enabled ? {\n            data: undefined,\n            error: null,\n            status: 'connecting',\n            reset\n        } : {\n            data: undefined,\n            error: null,\n            status: 'idle',\n            reset\n        };\n    }, [\n        opts.enabled,\n        reset\n    ]);\n    const resultRef = React.useRef(getInitialState());\n    const [state, setState] = React.useState(trackResult(resultRef.current, addTrackedProp));\n    state.reset = reset;\n    const updateState = React.useCallback((callback)=>{\n        const prev = resultRef.current;\n        const next = resultRef.current = callback(prev);\n        let shouldUpdate = false;\n        for (const key of trackedProps.current){\n            if (prev[key] !== next[key]) {\n                shouldUpdate = true;\n                break;\n            }\n        }\n        if (shouldUpdate) {\n            setState(trackResult(next, addTrackedProp));\n        }\n    }, [\n        addTrackedProp\n    ]);\n    React.useEffect(()=>{\n        if (!opts.enabled) {\n            return;\n        }\n        reset();\n        return ()=>{\n            currentSubscriptionRef.current?.();\n        };\n    }, [\n        reset,\n        opts.enabled\n    ]);\n    return state;\n}\nfunction trackResult(result, onTrackResult) {\n    const trackedResult = new Proxy(result, {\n        get (target, prop) {\n            onTrackResult(prop);\n            return target[prop];\n        }\n    });\n    return trackedResult;\n}\n\nexport { trpcSubscriptionOptions, useSubscription };\n", "import { TRPCUntypedClient, getUntypedClient } from '@trpc/client';\nimport { createTRPCRecursiveProxy, callTRPCProcedure } from '@trpc/server';\nimport { trpcInfiniteQueryOptions } from './infiniteQueryOptions.mjs';\nimport { trpcMutationOptions } from './mutationOptions.mjs';\nimport { trpcQueryOptions } from './queryOptions.mjs';\nimport { trpcSubscriptionOptions } from './subscriptionOptions.mjs';\nimport { getQueryKeyInternal, getMutationKeyInternal, unwrapLazyArg } from './utils.mjs';\n\n/**\n * Create a typed proxy from your router types. Can also be used on the server.\n *\n * @see https://trpc.io/docs/client/tanstack-react-query/setup#3b-setup-without-react-context\n * @see https://trpc.io/docs/client/tanstack-react-query/server-components#5-create-a-trpc-caller-for-server-components\n */ function createTRPCOptionsProxy(opts) {\n    const callIt = (type)=>{\n        return (path, input, trpcOpts)=>{\n            if ('router' in opts) {\n                return Promise.resolve(unwrapLazyArg(opts.ctx)).then((ctx)=>callTRPCProcedure({\n                        router: opts.router,\n                        path: path,\n                        getRawInput: async ()=>input,\n                        ctx: ctx,\n                        type: type,\n                        signal: undefined\n                    }));\n            }\n            const untypedClient = opts.client instanceof TRPCUntypedClient ? opts.client : getUntypedClient(opts.client);\n            return untypedClient[type](path, input, trpcOpts);\n        };\n    };\n    return createTRPCRecursiveProxy(({ args, path: _path })=>{\n        const path = [\n            ..._path\n        ];\n        const utilName = path.pop();\n        const [arg1, arg2] = args;\n        const contextMap = {\n            '~types': undefined,\n            pathKey: ()=>{\n                return getQueryKeyInternal(path);\n            },\n            pathFilter: ()=>{\n                return {\n                    ...arg1,\n                    queryKey: getQueryKeyInternal(path)\n                };\n            },\n            queryOptions: ()=>{\n                return trpcQueryOptions({\n                    input: arg1,\n                    opts: arg2,\n                    path,\n                    queryClient: opts.queryClient,\n                    queryKey: getQueryKeyInternal(path, arg1, 'query'),\n                    query: callIt('query')\n                });\n            },\n            queryKey: ()=>{\n                return getQueryKeyInternal(path, arg1, 'query');\n            },\n            queryFilter: ()=>{\n                return {\n                    ...arg2,\n                    queryKey: getQueryKeyInternal(path, arg1, 'query')\n                };\n            },\n            infiniteQueryOptions: ()=>{\n                return trpcInfiniteQueryOptions({\n                    input: arg1,\n                    opts: arg2,\n                    path,\n                    queryClient: opts.queryClient,\n                    queryKey: getQueryKeyInternal(path, arg1, 'infinite'),\n                    query: callIt('query')\n                });\n            },\n            infiniteQueryKey: ()=>{\n                return getQueryKeyInternal(path, arg1, 'infinite');\n            },\n            infiniteQueryFilter: ()=>{\n                return {\n                    ...arg2,\n                    queryKey: getQueryKeyInternal(path, arg1, 'infinite')\n                };\n            },\n            mutationOptions: ()=>{\n                return trpcMutationOptions({\n                    opts: arg1,\n                    path,\n                    queryClient: opts.queryClient,\n                    mutate: callIt('mutation'),\n                    overrides: opts.overrides?.mutations\n                });\n            },\n            mutationKey: ()=>{\n                return getMutationKeyInternal(path);\n            },\n            subscriptionOptions: ()=>{\n                return trpcSubscriptionOptions({\n                    opts: arg2,\n                    path,\n                    queryKey: getQueryKeyInternal(path, arg1, 'any'),\n                    subscribe: callIt('subscription')\n                });\n            }\n        };\n        return contextMap[utilName]();\n    });\n}\n\nexport { createTRPCOptionsProxy };\n"],
  "mappings": "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",
  "names": ["React", "args", "_a"]
}
