import {
  hashKey,
  infiniteQueryOptions,
  queryOptions,
  skipToken
} from "./chunk-XMJCO26T.js";
import "./chunk-XDIZUD3C.js";
import {
  require_react
} from "./chunk-HJ2TN74Q.js";
import {
  __toESM
} from "./chunk-45IN2YCG.js";

// node_modules/@trpc/tanstack-react-query/dist/internals/Context.mjs
var React2 = __toESM(require_react(), 1);

// node_modules/@trpc/server/dist/observable/observable.mjs
function observable(subscribe) {
  const self = {
    subscribe(observer) {
      let teardownRef = null;
      let isDone = false;
      let unsubscribed = false;
      let teardownImmediately = false;
      function unsubscribe() {
        if (teardownRef === null) {
          teardownImmediately = true;
          return;
        }
        if (unsubscribed) {
          return;
        }
        unsubscribed = true;
        if (typeof teardownRef === "function") {
          teardownRef();
        } else if (teardownRef) {
          teardownRef.unsubscribe();
        }
      }
      teardownRef = subscribe({
        next(value) {
          var _a2;
          if (isDone) {
            return;
          }
          (_a2 = observer.next) == null ? void 0 : _a2.call(observer, value);
        },
        error(err) {
          var _a2;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a2 = observer.error) == null ? void 0 : _a2.call(observer, err);
          unsubscribe();
        },
        complete() {
          var _a2;
          if (isDone) {
            return;
          }
          isDone = true;
          (_a2 = observer.complete) == null ? void 0 : _a2.call(observer);
          unsubscribe();
        }
      });
      if (teardownImmediately) {
        unsubscribe();
      }
      return {
        unsubscribe
      };
    },
    pipe(...operations) {
      return operations.reduce(pipeReducer, self);
    }
  };
  return self;
}
function pipeReducer(prev, fn) {
  return fn(prev);
}
function observableToPromise(observable2) {
  const ac = new AbortController();
  const promise = new Promise((resolve, reject) => {
    let isDone = false;
    function onDone() {
      if (isDone) {
        return;
      }
      isDone = true;
      obs$.unsubscribe();
    }
    ac.signal.addEventListener("abort", () => {
      reject(ac.signal.reason);
    });
    const obs$ = observable2.subscribe({
      next(data) {
        isDone = true;
        resolve(data);
        onDone();
      },
      error(data) {
        reject(data);
      },
      complete() {
        ac.abort();
        onDone();
      }
    });
  });
  return promise;
}

// node_modules/@trpc/server/dist/observable/operators.mjs
function share(_opts) {
  return (source) => {
    let refCount = 0;
    let subscription = null;
    const observers = [];
    function startIfNeeded() {
      if (subscription) {
        return;
      }
      subscription = source.subscribe({
        next(value) {
          var _a2;
          for (const observer of observers) {
            (_a2 = observer.next) == null ? void 0 : _a2.call(observer, value);
          }
        },
        error(error) {
          var _a2;
          for (const observer of observers) {
            (_a2 = observer.error) == null ? void 0 : _a2.call(observer, error);
          }
        },
        complete() {
          var _a2;
          for (const observer of observers) {
            (_a2 = observer.complete) == null ? void 0 : _a2.call(observer);
          }
        }
      });
    }
    function resetIfNeeded() {
      if (refCount === 0 && subscription) {
        const _sub = subscription;
        subscription = null;
        _sub.unsubscribe();
      }
    }
    return observable((subscriber) => {
      refCount++;
      observers.push(subscriber);
      startIfNeeded();
      return {
        unsubscribe() {
          refCount--;
          resetIfNeeded();
          const index = observers.findIndex((v) => v === subscriber);
          if (index > -1) {
            observers.splice(index, 1);
          }
        }
      };
    });
  };
}
var distinctUnsetMarker = Symbol();

// node_modules/@trpc/server/dist/observable/behaviorSubject.mjs
function behaviorSubject(initialValue) {
  let value = initialValue;
  const observerList = [];
  const addObserver = (observer) => {
    if (value !== void 0) {
      observer.next(value);
    }
    observerList.push(observer);
  };
  const removeObserver = (observer) => {
    observerList.splice(observerList.indexOf(observer), 1);
  };
  const obs = observable((observer) => {
    addObserver(observer);
    return () => {
      removeObserver(observer);
    };
  });
  obs.next = (nextValue) => {
    if (value === nextValue) {
      return;
    }
    value = nextValue;
    for (const observer of observerList) {
      observer.next(nextValue);
    }
  };
  obs.get = () => value;
  return obs;
}

// node_modules/@trpc/client/dist/links/internals/createChain.mjs
function createChain(opts) {
  return observable((observer) => {
    function execute(index = 0, op = opts.op) {
      const next = opts.links[index];
      if (!next) {
        throw new Error("No more links to execute - did you forget to add an ending link?");
      }
      const subscription = next({
        op,
        next(nextOp) {
          const nextObserver = execute(index + 1, nextOp);
          return nextObserver;
        }
      });
      return subscription;
    }
    const obs$ = execute();
    return obs$.subscribe(observer);
  });
}

// node_modules/@trpc/server/dist/unstable-core-do-not-import/createProxy.mjs
var noop = () => {
};
var freezeIfAvailable = (obj) => {
  if (Object.freeze) {
    Object.freeze(obj);
  }
};
function createInnerProxy(callback, path, memo) {
  var _memo, _cacheKey;
  const cacheKey = path.join(".");
  (_memo = memo)[_cacheKey = cacheKey] ?? (_memo[_cacheKey] = new Proxy(noop, {
    get(_obj, key) {
      if (typeof key !== "string" || key === "then") {
        return void 0;
      }
      return createInnerProxy(callback, [
        ...path,
        key
      ], memo);
    },
    apply(_1, _2, args) {
      const lastOfPath = path[path.length - 1];
      let opts = {
        args,
        path
      };
      if (lastOfPath === "call") {
        opts = {
          args: args.length >= 2 ? [
            args[1]
          ] : [],
          path: path.slice(0, -1)
        };
      } else if (lastOfPath === "apply") {
        opts = {
          args: args.length >= 2 ? args[1] : [],
          path: path.slice(0, -1)
        };
      }
      freezeIfAvailable(opts.args);
      freezeIfAvailable(opts.path);
      return callback(opts);
    }
  }));
  return memo[cacheKey];
}
var createRecursiveProxy = (callback) => createInnerProxy(callback, [], /* @__PURE__ */ Object.create(null));

// node_modules/@trpc/server/dist/unstable-core-do-not-import/error/formatter.mjs
var defaultFormatter = ({ shape }) => {
  return shape;
};

// node_modules/@trpc/server/dist/unstable-core-do-not-import/rpc/codes.mjs
var TRPC_ERROR_CODES_BY_KEY = {
  /**
  * Invalid JSON was received by the server.
  * An error occurred on the server while parsing the JSON text.
  */
  PARSE_ERROR: -32700,
  /**
  * The JSON sent is not a valid Request object.
  */
  BAD_REQUEST: -32600,
  // Internal JSON-RPC error
  INTERNAL_SERVER_ERROR: -32603,
  NOT_IMPLEMENTED: -32603,
  BAD_GATEWAY: -32603,
  SERVICE_UNAVAILABLE: -32603,
  GATEWAY_TIMEOUT: -32603,
  // Implementation specific errors
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  UNSUPPORTED_MEDIA_TYPE: -32015,
  UNPROCESSABLE_CONTENT: -32022,
  TOO_MANY_REQUESTS: -32029,
  CLIENT_CLOSED_REQUEST: -32099
};

// node_modules/@trpc/server/dist/unstable-core-do-not-import/utils.mjs
var unsetMarker = Symbol();
function mergeWithoutOverrides(obj1, ...objs) {
  const newObj = Object.assign(/* @__PURE__ */ Object.create(null), obj1);
  for (const overrides of objs) {
    for (const key in overrides) {
      if (key in newObj && newObj[key] !== overrides[key]) {
        throw new Error(`Duplicate key ${key}`);
      }
      newObj[key] = overrides[key];
    }
  }
  return newObj;
}
function isObject(value) {
  return !!value && !Array.isArray(value) && typeof value === "object";
}
function isFunction(fn) {
  return typeof fn === "function";
}
function omitPrototype(obj) {
  return Object.assign(/* @__PURE__ */ Object.create(null), obj);
}
var asyncIteratorsSupported = typeof Symbol === "function" && !!Symbol.asyncIterator;
function isAsyncIterable(value) {
  return asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;
}

// node_modules/@trpc/server/dist/unstable-core-do-not-import/error/TRPCError.mjs
function _define_property(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var UnknownCauseError = class extends Error {
};
function getCauseFromUnknown(cause) {
  if (cause instanceof Error) {
    return cause;
  }
  const type = typeof cause;
  if (type === "undefined" || type === "function" || cause === null) {
    return void 0;
  }
  if (type !== "object") {
    return new Error(String(cause));
  }
  if (isObject(cause)) {
    const err = new UnknownCauseError();
    for (const key in cause) {
      err[key] = cause[key];
    }
    return err;
  }
  return void 0;
}
function getTRPCErrorFromUnknown(cause) {
  if (cause instanceof TRPCError) {
    return cause;
  }
  if (cause instanceof Error && cause.name === "TRPCError") {
    return cause;
  }
  const trpcError = new TRPCError({
    code: "INTERNAL_SERVER_ERROR",
    cause
  });
  if (cause instanceof Error && cause.stack) {
    trpcError.stack = cause.stack;
  }
  return trpcError;
}
var TRPCError = class extends Error {
  constructor(opts) {
    const cause = getCauseFromUnknown(opts.cause);
    const message = opts.message ?? (cause == null ? void 0 : cause.message) ?? opts.code;
    super(message, {
      cause
    }), // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore override doesn't work in all environments due to "This member cannot have an 'override' modifier because it is not declared in the base class 'Error'"
    _define_property(this, "cause", void 0), _define_property(this, "code", void 0);
    this.code = opts.code;
    this.name = "TRPCError";
    if (!this.cause) {
      this.cause = cause;
    }
  }
};

// node_modules/@trpc/server/dist/unstable-core-do-not-import/transformer.mjs
function getDataTransformer(transformer) {
  if ("input" in transformer) {
    return transformer;
  }
  return {
    input: transformer,
    output: transformer
  };
}
var defaultTransformer = {
  input: {
    serialize: (obj) => obj,
    deserialize: (obj) => obj
  },
  output: {
    serialize: (obj) => obj,
    deserialize: (obj) => obj
  }
};

// node_modules/@trpc/server/dist/unstable-core-do-not-import/router.mjs
var lazySymbol = Symbol("lazy");
function once(fn) {
  const uncalled = Symbol();
  let result = uncalled;
  return () => {
    if (result === uncalled) {
      result = fn();
    }
    return result;
  };
}
function isLazy(input) {
  return typeof input === "function" && lazySymbol in input;
}
function isRouter(value) {
  return isObject(value) && isObject(value["_def"]) && "router" in value["_def"];
}
var emptyRouter = {
  _ctx: null,
  _errorShape: null,
  _meta: null,
  queries: {},
  mutations: {},
  subscriptions: {},
  errorFormatter: defaultFormatter,
  transformer: defaultTransformer
};
var reservedWords = [
  /**
  * Then is a reserved word because otherwise we can't return a promise that returns a Proxy
  * since JS will think that `.then` is something that exists
  */
  "then",
  /**
  * `fn.call()` and `fn.apply()` are reserved words because otherwise we can't call a function using `.call` or `.apply`
  */
  "call",
  "apply"
];
function createRouterFactory(config) {
  function createRouterInner(input) {
    const reservedWordsUsed = new Set(Object.keys(input).filter((v) => reservedWords.includes(v)));
    if (reservedWordsUsed.size > 0) {
      throw new Error("Reserved words used in `router({})` call: " + Array.from(reservedWordsUsed).join(", "));
    }
    const procedures = omitPrototype({});
    const lazy2 = omitPrototype({});
    function createLazyLoader(opts) {
      return {
        ref: opts.ref,
        load: once(async () => {
          const router2 = await opts.ref();
          const lazyPath = [
            ...opts.path,
            opts.key
          ];
          const lazyKey = lazyPath.join(".");
          opts.aggregate[opts.key] = step(router2._def.record, lazyPath);
          delete lazy2[lazyKey];
          for (const [nestedKey, nestedItem] of Object.entries(router2._def.lazy)) {
            const nestedRouterKey = [
              ...lazyPath,
              nestedKey
            ].join(".");
            lazy2[nestedRouterKey] = createLazyLoader({
              ref: nestedItem.ref,
              path: lazyPath,
              key: nestedKey,
              aggregate: opts.aggregate[opts.key]
            });
          }
        })
      };
    }
    function step(from, path = []) {
      const aggregate = omitPrototype({});
      for (const [key, item] of Object.entries(from ?? {})) {
        if (isLazy(item)) {
          lazy2[[
            ...path,
            key
          ].join(".")] = createLazyLoader({
            path,
            ref: item,
            key,
            aggregate
          });
          continue;
        }
        if (isRouter(item)) {
          aggregate[key] = step(item._def.record, [
            ...path,
            key
          ]);
          continue;
        }
        if (!isProcedure(item)) {
          aggregate[key] = step(item, [
            ...path,
            key
          ]);
          continue;
        }
        const newPath = [
          ...path,
          key
        ].join(".");
        if (procedures[newPath]) {
          throw new Error(`Duplicate key: ${newPath}`);
        }
        procedures[newPath] = item;
        aggregate[key] = item;
      }
      return aggregate;
    }
    const record = step(input);
    const _def = {
      _config: config,
      router: true,
      procedures,
      lazy: lazy2,
      ...emptyRouter,
      record
    };
    const router = {
      ...record,
      _def,
      createCaller: createCallerFactory()({
        _def
      })
    };
    return router;
  }
  return createRouterInner;
}
function isProcedure(procedureOrRouter) {
  return typeof procedureOrRouter === "function";
}
async function getProcedureAtPath(router, path) {
  const { _def } = router;
  let procedure = _def.procedures[path];
  while (!procedure) {
    const key = Object.keys(_def.lazy).find((key2) => path.startsWith(key2));
    if (!key) {
      return null;
    }
    const lazyRouter = _def.lazy[key];
    await lazyRouter.load();
    procedure = _def.procedures[path];
  }
  return procedure;
}
async function callProcedure(opts) {
  const { type, path } = opts;
  const proc = await getProcedureAtPath(opts.router, path);
  if (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) {
    throw new TRPCError({
      code: "NOT_FOUND",
      message: `No "${type}"-procedure on path "${path}"`
    });
  }
  if (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === "subscription") {
    throw new TRPCError({
      code: "METHOD_NOT_SUPPORTED",
      message: `Method override is not supported for subscriptions`
    });
  }
  return proc(opts);
}
function createCallerFactory() {
  return function createCallerInner(router) {
    const { _def } = router;
    return function createCaller(ctxOrCallback, opts) {
      return createRecursiveProxy(async ({ path, args }) => {
        var _a2;
        const fullPath = path.join(".");
        if (path.length === 1 && path[0] === "_def") {
          return _def;
        }
        const procedure = await getProcedureAtPath(router, fullPath);
        let ctx = void 0;
        try {
          if (!procedure) {
            throw new TRPCError({
              code: "NOT_FOUND",
              message: `No procedure found on path "${path}"`
            });
          }
          ctx = isFunction(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;
          return await procedure({
            path: fullPath,
            getRawInput: async () => args[0],
            ctx,
            type: procedure._def.type,
            signal: opts == null ? void 0 : opts.signal
          });
        } catch (cause) {
          (_a2 = opts == null ? void 0 : opts.onError) == null ? void 0 : _a2.call(opts, {
            ctx,
            error: getTRPCErrorFromUnknown(cause),
            input: args[0],
            path: fullPath,
            type: (procedure == null ? void 0 : procedure._def.type) ?? "unknown"
          });
          throw cause;
        }
      });
    };
  };
}
function mergeRouters(...routerList) {
  var _a2;
  const record = mergeWithoutOverrides({}, ...routerList.map((r) => r._def.record));
  const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter) => {
    if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {
      if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {
        throw new Error("You seem to have several error formatters");
      }
      return nextRouter._def._config.errorFormatter;
    }
    return currentErrorFormatter;
  }, defaultFormatter);
  const transformer = routerList.reduce((prev, current) => {
    if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {
      if (prev !== defaultTransformer && prev !== current._def._config.transformer) {
        throw new Error("You seem to have several transformers");
      }
      return current._def._config.transformer;
    }
    return prev;
  }, defaultTransformer);
  const router = createRouterFactory({
    errorFormatter,
    transformer,
    isDev: routerList.every((r) => r._def._config.isDev),
    allowOutsideOfServer: routerList.every((r) => r._def._config.allowOutsideOfServer),
    isServer: routerList.every((r) => r._def._config.isServer),
    $types: (_a2 = routerList[0]) == null ? void 0 : _a2._def._config.$types
  })(record);
  return router;
}

// node_modules/@trpc/server/dist/vendor/unpromise/unpromise.mjs
var _computedKey;
_computedKey = Symbol.toStringTag;

// node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/disposable.mjs
var _Symbol;
var _Symbol1;
(_Symbol = Symbol).dispose ?? (_Symbol.dispose = Symbol());
(_Symbol1 = Symbol).asyncDispose ?? (_Symbol1.asyncDispose = Symbol());

// node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/timerResource.mjs
var disposablePromiseTimerResult = Symbol();

// node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/utils/withPing.mjs
var PING_SYM = Symbol("ping");

// node_modules/@trpc/server/dist/unstable-core-do-not-import/stream/tracked.mjs
var trackedSymbol = Symbol();

// node_modules/@trpc/server/dist/unstable-core-do-not-import/middleware.mjs
var middlewareMarker = "middlewareMarker";
function createMiddlewareFactory() {
  function createMiddlewareInner(middlewares) {
    return {
      _middlewares: middlewares,
      unstable_pipe(middlewareBuilderOrFn) {
        const pipedMiddleware = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
          middlewareBuilderOrFn
        ];
        return createMiddlewareInner([
          ...middlewares,
          ...pipedMiddleware
        ]);
      }
    };
  }
  function createMiddleware(fn) {
    return createMiddlewareInner([
      fn
    ]);
  }
  return createMiddleware;
}
function createInputMiddleware(parse) {
  const inputMiddleware = async function inputValidatorMiddleware(opts) {
    let parsedInput;
    const rawInput = await opts.getRawInput();
    try {
      parsedInput = await parse(rawInput);
    } catch (cause) {
      throw new TRPCError({
        code: "BAD_REQUEST",
        cause
      });
    }
    const combinedInput = isObject(opts.input) && isObject(parsedInput) ? {
      ...opts.input,
      ...parsedInput
    } : parsedInput;
    return opts.next({
      input: combinedInput
    });
  };
  inputMiddleware._type = "input";
  return inputMiddleware;
}
function createOutputMiddleware(parse) {
  const outputMiddleware = async function outputValidatorMiddleware({ next }) {
    const result = await next();
    if (!result.ok) {
      return result;
    }
    try {
      const data = await parse(result.data);
      return {
        ...result,
        data
      };
    } catch (cause) {
      throw new TRPCError({
        message: "Output validation failed",
        code: "INTERNAL_SERVER_ERROR",
        cause
      });
    }
  };
  outputMiddleware._type = "output";
  return outputMiddleware;
}

// node_modules/@trpc/server/dist/vendor/standard-schema-v1/error.mjs
function _define_property2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandardSchemaV1Error = class extends Error {
  /**
  * Creates a schema error with useful information.
  *
  * @param issues The schema issues.
  */
  constructor(issues) {
    var _a2;
    super((_a2 = issues[0]) == null ? void 0 : _a2.message), /** The schema issues. */
    _define_property2(this, "issues", void 0);
    this.name = "SchemaError";
    this.issues = issues;
  }
};

// node_modules/@trpc/server/dist/unstable-core-do-not-import/parser.mjs
function getParseFn(procedureParser) {
  const parser = procedureParser;
  if (typeof parser === "function" && typeof parser.assert === "function") {
    return parser.assert.bind(parser);
  }
  if (typeof parser === "function") {
    return parser;
  }
  if (typeof parser.parseAsync === "function") {
    return parser.parseAsync.bind(parser);
  }
  if (typeof parser.parse === "function") {
    return parser.parse.bind(parser);
  }
  if (typeof parser.validateSync === "function") {
    return parser.validateSync.bind(parser);
  }
  if (typeof parser.create === "function") {
    return parser.create.bind(parser);
  }
  if (typeof parser.assert === "function") {
    return (value) => {
      parser.assert(value);
      return value;
    };
  }
  if ("~standard" in parser) {
    return async (value) => {
      const result = await parser["~standard"].validate(value);
      if (result.issues) {
        throw new StandardSchemaV1Error(result.issues);
      }
      return result.value;
    };
  }
  throw new Error("Could not find a validator fn");
}

// node_modules/@trpc/server/dist/unstable-core-do-not-import/procedureBuilder.mjs
function createNewBuilder(def1, def2) {
  const { middlewares = [], inputs, meta, ...rest } = def2;
  return createBuilder({
    ...mergeWithoutOverrides(def1, rest),
    inputs: [
      ...def1.inputs,
      ...inputs ?? []
    ],
    middlewares: [
      ...def1.middlewares,
      ...middlewares
    ],
    meta: def1.meta && meta ? {
      ...def1.meta,
      ...meta
    } : meta ?? def1.meta
  });
}
function createBuilder(initDef = {}) {
  const _def = {
    procedure: true,
    inputs: [],
    middlewares: [],
    ...initDef
  };
  const builder = {
    _def,
    input(input) {
      const parser = getParseFn(input);
      return createNewBuilder(_def, {
        inputs: [
          input
        ],
        middlewares: [
          createInputMiddleware(parser)
        ]
      });
    },
    output(output) {
      const parser = getParseFn(output);
      return createNewBuilder(_def, {
        output,
        middlewares: [
          createOutputMiddleware(parser)
        ]
      });
    },
    meta(meta) {
      return createNewBuilder(_def, {
        meta
      });
    },
    use(middlewareBuilderOrFn) {
      const middlewares = "_middlewares" in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [
        middlewareBuilderOrFn
      ];
      return createNewBuilder(_def, {
        middlewares
      });
    },
    unstable_concat(builder2) {
      return createNewBuilder(_def, builder2._def);
    },
    concat(builder2) {
      return createNewBuilder(_def, builder2._def);
    },
    query(resolver) {
      return createResolver({
        ..._def,
        type: "query"
      }, resolver);
    },
    mutation(resolver) {
      return createResolver({
        ..._def,
        type: "mutation"
      }, resolver);
    },
    subscription(resolver) {
      return createResolver({
        ..._def,
        type: "subscription"
      }, resolver);
    },
    experimental_caller(caller) {
      return createNewBuilder(_def, {
        caller
      });
    }
  };
  return builder;
}
function createResolver(_defIn, resolver) {
  const finalBuilder = createNewBuilder(_defIn, {
    resolver,
    middlewares: [
      async function resolveMiddleware(opts) {
        const data = await resolver(opts);
        return {
          marker: middlewareMarker,
          ok: true,
          data,
          ctx: opts.ctx
        };
      }
    ]
  });
  const _def = {
    ...finalBuilder._def,
    type: _defIn.type,
    experimental_caller: Boolean(finalBuilder._def.caller),
    meta: finalBuilder._def.meta,
    $types: null
  };
  const invoke = createProcedureCaller(finalBuilder._def);
  const callerOverride = finalBuilder._def.caller;
  if (!callerOverride) {
    return invoke;
  }
  const callerWrapper = async (...args) => {
    return await callerOverride({
      args,
      invoke,
      _def
    });
  };
  callerWrapper._def = _def;
  return callerWrapper;
}
var codeblock = `
This is a client-only function.
If you want to call this function on the server, see https://trpc.io/docs/v11/server/server-side-calls
`.trim();
async function callRecursive(index, _def, opts) {
  try {
    const middleware = _def.middlewares[index];
    const result = await middleware({
      ...opts,
      meta: _def.meta,
      input: opts.input,
      next(_nextOpts) {
        const nextOpts = _nextOpts;
        return callRecursive(index + 1, _def, {
          ...opts,
          ctx: (nextOpts == null ? void 0 : nextOpts.ctx) ? {
            ...opts.ctx,
            ...nextOpts.ctx
          } : opts.ctx,
          input: nextOpts && "input" in nextOpts ? nextOpts.input : opts.input,
          getRawInput: (nextOpts == null ? void 0 : nextOpts.getRawInput) ?? opts.getRawInput
        });
      }
    });
    return result;
  } catch (cause) {
    return {
      ok: false,
      error: getTRPCErrorFromUnknown(cause),
      marker: middlewareMarker
    };
  }
}
function createProcedureCaller(_def) {
  async function procedure(opts) {
    if (!opts || !("getRawInput" in opts)) {
      throw new Error(codeblock);
    }
    const result = await callRecursive(0, _def, opts);
    if (!result) {
      throw new TRPCError({
        code: "INTERNAL_SERVER_ERROR",
        message: "No result from middlewares - did you forget to `return next()`?"
      });
    }
    if (!result.ok) {
      throw result.error;
    }
    return result.data;
  }
  procedure._def = _def;
  procedure.procedure = true;
  return procedure;
}

// node_modules/@trpc/server/dist/unstable-core-do-not-import/rootConfig.mjs
var _a, _b, _c, _d, _e, _f;
var isServerDefault = typeof window === "undefined" || "Deno" in window || // eslint-disable-next-line @typescript-eslint/dot-notation
((_b = (_a = globalThis.process) == null ? void 0 : _a.env) == null ? void 0 : _b["NODE_ENV"]) === "test" || !!((_d = (_c = globalThis.process) == null ? void 0 : _c.env) == null ? void 0 : _d["JEST_WORKER_ID"]) || !!((_f = (_e = globalThis.process) == null ? void 0 : _e.env) == null ? void 0 : _f["VITEST_WORKER_ID"]);

// node_modules/@trpc/server/dist/unstable-core-do-not-import/initTRPC.mjs
var TRPCBuilder = class _TRPCBuilder {
  /**
  * Add a context shape as a generic to the root object
  * @see https://trpc.io/docs/v11/server/context
  */
  context() {
    return new _TRPCBuilder();
  }
  /**
  * Add a meta shape as a generic to the root object
  * @see https://trpc.io/docs/v11/quickstart
  */
  meta() {
    return new _TRPCBuilder();
  }
  /**
  * Create the root object
  * @see https://trpc.io/docs/v11/server/routers#initialize-trpc
  */
  create(opts) {
    var _a2;
    const config = {
      ...opts,
      transformer: getDataTransformer((opts == null ? void 0 : opts.transformer) ?? defaultTransformer),
      isDev: (opts == null ? void 0 : opts.isDev) ?? // eslint-disable-next-line @typescript-eslint/dot-notation
      ((_a2 = globalThis.process) == null ? void 0 : _a2.env["NODE_ENV"]) !== "production",
      allowOutsideOfServer: (opts == null ? void 0 : opts.allowOutsideOfServer) ?? false,
      errorFormatter: (opts == null ? void 0 : opts.errorFormatter) ?? defaultFormatter,
      isServer: (opts == null ? void 0 : opts.isServer) ?? isServerDefault,
      /**
      * These are just types, they can't be used at runtime
      * @internal
      */
      $types: null
    };
    {
      const isServer = (opts == null ? void 0 : opts.isServer) ?? isServerDefault;
      if (!isServer && (opts == null ? void 0 : opts.allowOutsideOfServer) !== true) {
        throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);
      }
    }
    return {
      /**
      * Your router config
      * @internal
      */
      _config: config,
      /**
      * Builder object for creating procedures
      * @see https://trpc.io/docs/v11/server/procedures
      */
      procedure: createBuilder({
        meta: opts == null ? void 0 : opts.defaultMeta
      }),
      /**
      * Create reusable middlewares
      * @see https://trpc.io/docs/v11/server/middlewares
      */
      middleware: createMiddlewareFactory(),
      /**
      * Create a router
      * @see https://trpc.io/docs/v11/server/routers
      */
      router: createRouterFactory(config),
      /**
      * Merge Routers
      * @see https://trpc.io/docs/v11/server/merging-routers
      */
      mergeRouters,
      /**
      * Create a server-side caller for a router
      * @see https://trpc.io/docs/v11/server/server-side-calls
      */
      createCallerFactory: createCallerFactory()
    };
  }
};
var initTRPC = new TRPCBuilder();

// node_modules/@trpc/client/dist/TRPCClientError.mjs
function _define_property3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function isTRPCClientError(cause) {
  return cause instanceof TRPCClientError || /**
  * @deprecated
  * Delete in next major
  */
  cause instanceof Error && cause.name === "TRPCClientError";
}
function isTRPCErrorResponse(obj) {
  return isObject(obj) && isObject(obj["error"]) && typeof obj["error"]["code"] === "number" && typeof obj["error"]["message"] === "string";
}
function getMessageFromUnknownError(err, fallback) {
  if (typeof err === "string") {
    return err;
  }
  if (isObject(err) && typeof err["message"] === "string") {
    return err["message"];
  }
  return fallback;
}
var TRPCClientError = class _TRPCClientError extends Error {
  static from(_cause, opts = {}) {
    const cause = _cause;
    if (isTRPCClientError(cause)) {
      if (opts.meta) {
        cause.meta = {
          ...cause.meta,
          ...opts.meta
        };
      }
      return cause;
    }
    if (isTRPCErrorResponse(cause)) {
      return new _TRPCClientError(cause.error.message, {
        ...opts,
        result: cause
      });
    }
    return new _TRPCClientError(getMessageFromUnknownError(cause, "Unknown error"), {
      ...opts,
      cause
    });
  }
  constructor(message, opts) {
    var _a2, _b2;
    const cause = opts == null ? void 0 : opts.cause;
    super(message, {
      cause
    }), // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore override doesn't work in all environments due to "This member cannot have an 'override' modifier because it is not declared in the base class 'Error'"
    _define_property3(this, "cause", void 0), _define_property3(this, "shape", void 0), _define_property3(this, "data", void 0), /**
    * Additional meta data about the error
    * In the case of HTTP-errors, we'll have `response` and potentially `responseJSON` here
    */
    _define_property3(this, "meta", void 0);
    this.meta = opts == null ? void 0 : opts.meta;
    this.cause = cause;
    this.shape = (_a2 = opts == null ? void 0 : opts.result) == null ? void 0 : _a2.error;
    this.data = (_b2 = opts == null ? void 0 : opts.result) == null ? void 0 : _b2.error.data;
    this.name = "TRPCClientError";
    Object.setPrototypeOf(this, _TRPCClientError.prototype);
  }
};

// node_modules/@trpc/client/dist/internals/TRPCUntypedClient.mjs
function _define_property4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TRPCUntypedClient = class {
  $request(opts) {
    const chain$ = createChain({
      links: this.links,
      op: {
        ...opts,
        context: opts.context ?? {},
        id: ++this.requestId
      }
    });
    return chain$.pipe(share());
  }
  async requestAsPromise(opts) {
    try {
      const req$ = this.$request(opts);
      const envelope = await observableToPromise(req$);
      const data = envelope.result.data;
      return data;
    } catch (err) {
      throw TRPCClientError.from(err);
    }
  }
  query(path, input, opts) {
    return this.requestAsPromise({
      type: "query",
      path,
      input,
      context: opts == null ? void 0 : opts.context,
      signal: opts == null ? void 0 : opts.signal
    });
  }
  mutation(path, input, opts) {
    return this.requestAsPromise({
      type: "mutation",
      path,
      input,
      context: opts == null ? void 0 : opts.context,
      signal: opts == null ? void 0 : opts.signal
    });
  }
  subscription(path, input, opts) {
    const observable$ = this.$request({
      type: "subscription",
      path,
      input,
      context: opts.context,
      signal: opts.signal
    });
    return observable$.subscribe({
      next(envelope) {
        var _a2, _b2, _c2, _d2;
        switch (envelope.result.type) {
          case "state": {
            (_a2 = opts.onConnectionStateChange) == null ? void 0 : _a2.call(opts, envelope.result);
            break;
          }
          case "started": {
            (_b2 = opts.onStarted) == null ? void 0 : _b2.call(opts, {
              context: envelope.context
            });
            break;
          }
          case "stopped": {
            (_c2 = opts.onStopped) == null ? void 0 : _c2.call(opts);
            break;
          }
          case "data":
          case void 0: {
            (_d2 = opts.onData) == null ? void 0 : _d2.call(opts, envelope.result.data);
            break;
          }
        }
      },
      error(err) {
        var _a2;
        (_a2 = opts.onError) == null ? void 0 : _a2.call(opts, err);
      },
      complete() {
        var _a2;
        (_a2 = opts.onComplete) == null ? void 0 : _a2.call(opts);
      }
    });
  }
  constructor(opts) {
    _define_property4(this, "links", void 0);
    _define_property4(this, "runtime", void 0);
    _define_property4(this, "requestId", void 0);
    this.requestId = 0;
    this.runtime = {};
    this.links = opts.links.map((link) => link(this.runtime));
  }
};

// node_modules/@trpc/client/dist/createTRPCClient.mjs
var untypedClientSymbol = Symbol.for("trpc_untypedClient");
function getUntypedClient(client) {
  return client[untypedClientSymbol];
}

// node_modules/@trpc/client/dist/links/internals/urlWithConnectionParams.mjs
var resultOf = (value, ...args) => {
  return typeof value === "function" ? value(...args) : value;
};

// node_modules/@trpc/client/dist/links/wsLink/wsClient/utils.mjs
function withResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return {
    promise,
    resolve,
    reject
  };
}
async function prepareUrl(urlOptions) {
  const url = await resultOf(urlOptions.url);
  if (!urlOptions.connectionParams) return url;
  const prefix = url.includes("?") ? "&" : "?";
  const connectionParams = `${prefix}connectionParams=1`;
  return url + connectionParams;
}
async function buildConnectionMessage(connectionParams) {
  const message = {
    method: "connectionParams",
    data: await resultOf(connectionParams)
  };
  return JSON.stringify(message);
}

// node_modules/@trpc/client/dist/links/wsLink/wsClient/wsConnection.mjs
function _define_property5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function asyncWsOpen(ws) {
  const { promise, resolve, reject } = withResolvers();
  ws.addEventListener("open", () => {
    ws.removeEventListener("error", reject);
    resolve();
  });
  ws.addEventListener("error", reject);
  return promise;
}
function setupPingInterval(ws, { intervalMs, pongTimeoutMs }) {
  let pingTimeout;
  let pongTimeout;
  function start() {
    pingTimeout = setTimeout(() => {
      ws.send("PING");
      pongTimeout = setTimeout(() => {
        ws.close();
      }, pongTimeoutMs);
    }, intervalMs);
  }
  function reset() {
    clearTimeout(pingTimeout);
    start();
  }
  function pong() {
    clearTimeout(pongTimeout);
    reset();
  }
  ws.addEventListener("open", start);
  ws.addEventListener("message", ({ data }) => {
    clearTimeout(pingTimeout);
    start();
    if (data === "PONG") {
      pong();
    }
  });
  ws.addEventListener("close", () => {
    clearTimeout(pingTimeout);
    clearTimeout(pongTimeout);
  });
}
var WsConnection = class _WsConnection {
  get ws() {
    return this.wsObservable.get();
  }
  set ws(ws) {
    this.wsObservable.next(ws);
  }
  /**
  * Checks if the WebSocket connection is open and ready to communicate.
  */
  isOpen() {
    return !!this.ws && this.ws.readyState === this.WebSocketPonyfill.OPEN && !this.openPromise;
  }
  /**
  * Checks if the WebSocket connection is closed or in the process of closing.
  */
  isClosed() {
    return !!this.ws && (this.ws.readyState === this.WebSocketPonyfill.CLOSING || this.ws.readyState === this.WebSocketPonyfill.CLOSED);
  }
  async open() {
    if (this.openPromise) return this.openPromise;
    this.id = ++_WsConnection.connectCount;
    const wsPromise = prepareUrl(this.urlOptions).then((url) => new this.WebSocketPonyfill(url));
    this.openPromise = wsPromise.then(async (ws) => {
      this.ws = ws;
      ws.addEventListener("message", function({ data }) {
        if (data === "PING") {
          this.send("PONG");
        }
      });
      if (this.keepAliveOpts.enabled) {
        setupPingInterval(ws, this.keepAliveOpts);
      }
      ws.addEventListener("close", () => {
        if (this.ws === ws) {
          this.ws = null;
        }
      });
      await asyncWsOpen(ws);
      if (this.urlOptions.connectionParams) {
        ws.send(await buildConnectionMessage(this.urlOptions.connectionParams));
      }
    });
    try {
      await this.openPromise;
    } finally {
      this.openPromise = null;
    }
  }
  /**
  * Closes the WebSocket connection gracefully.
  * Waits for any ongoing open operation to complete before closing.
  */
  async close() {
    var _a2;
    try {
      await this.openPromise;
    } finally {
      (_a2 = this.ws) == null ? void 0 : _a2.close();
    }
  }
  constructor(opts) {
    _define_property5(this, "id", ++_WsConnection.connectCount);
    _define_property5(this, "WebSocketPonyfill", void 0);
    _define_property5(this, "urlOptions", void 0);
    _define_property5(this, "keepAliveOpts", void 0);
    _define_property5(this, "wsObservable", behaviorSubject(null));
    _define_property5(this, "openPromise", null);
    this.WebSocketPonyfill = opts.WebSocketPonyfill ?? WebSocket;
    if (!this.WebSocketPonyfill) {
      throw new Error("No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill");
    }
    this.urlOptions = opts.urlOptions;
    this.keepAliveOpts = opts.keepAlive;
  }
};
_define_property5(WsConnection, "connectCount", 0);

// node_modules/@trpc/client/dist/links/httpSubscriptionLink.mjs
var codes5xx = [
  TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,
  TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,
  TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,
  TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR
];

// node_modules/@trpc/tanstack-react-query/dist/internals/utils.mjs
function createTRPCOptionsResult(value) {
  const path = value.path.join(".");
  return {
    path
  };
}
function getClientArgs(queryKey, opts, infiniteParams) {
  var _a2;
  const path = queryKey[0];
  let input = (_a2 = queryKey[1]) == null ? void 0 : _a2.input;
  if (infiniteParams) {
    input = {
      ...input ?? {},
      ...infiniteParams.pageParam !== void 0 ? {
        cursor: infiniteParams.pageParam
      } : {},
      direction: infiniteParams.direction
    };
  }
  return [
    path.join("."),
    input,
    opts == null ? void 0 : opts.trpc
  ];
}
async function buildQueryFromAsyncIterable(asyncIterable, queryClient, queryKey) {
  const queryCache = queryClient.getQueryCache();
  const query = queryCache.build(queryClient, {
    queryKey
  });
  query.setState({
    data: [],
    status: "success"
  });
  const aggregate = [];
  for await (const value of asyncIterable) {
    aggregate.push(value);
    query.setState({
      data: [
        ...aggregate
      ]
    });
  }
  return aggregate;
}
function getQueryKeyInternal(path, input, type) {
  const splitPath = path.flatMap((part) => part.split("."));
  if (!input && (!type || type === "any")) {
    return splitPath.length ? [
      splitPath
    ] : [];
  }
  if (type === "infinite" && isObject(input) && ("direction" in input || "cursor" in input)) {
    const { cursor: _, direction: __, ...inputWithoutCursorAndDirection } = input;
    return [
      splitPath,
      {
        input: inputWithoutCursorAndDirection,
        type: "infinite"
      }
    ];
  }
  return [
    splitPath,
    {
      ...typeof input !== "undefined" && input !== skipToken && {
        input
      },
      ...type && type !== "any" && {
        type
      }
    }
  ];
}
function getMutationKeyInternal(path) {
  const splitPath = path.flatMap((part) => part.split("."));
  return splitPath.length ? [
    splitPath
  ] : [];
}
function unwrapLazyArg(valueOrLazy) {
  return isFunction(valueOrLazy) ? valueOrLazy() : valueOrLazy;
}

// node_modules/@trpc/tanstack-react-query/dist/internals/infiniteQueryOptions.mjs
function trpcInfiniteQueryOptions(args) {
  const { input, query, path, queryKey, opts } = args;
  const inputIsSkipToken = input === skipToken;
  const queryFn = async (queryFnContext) => {
    var _a2;
    const actualOpts = {
      ...opts,
      trpc: {
        ...opts == null ? void 0 : opts.trpc,
        ...((_a2 = opts == null ? void 0 : opts.trpc) == null ? void 0 : _a2.abortOnUnmount) ? {
          signal: queryFnContext.signal
        } : {
          signal: null
        }
      }
    };
    const result = await query(...getClientArgs(queryKey, actualOpts, {
      direction: queryFnContext.direction,
      pageParam: queryFnContext.pageParam
    }));
    return result;
  };
  return Object.assign(infiniteQueryOptions({
    ...opts,
    queryKey,
    queryFn: inputIsSkipToken ? skipToken : queryFn,
    initialPageParam: (opts == null ? void 0 : opts.initialCursor) ?? (input == null ? void 0 : input.cursor)
  }), {
    trpc: createTRPCOptionsResult({
      path
    })
  });
}

// node_modules/@trpc/tanstack-react-query/dist/internals/mutationOptions.mjs
function trpcMutationOptions(args) {
  const { mutate, path, opts, overrides } = args;
  const queryClient = unwrapLazyArg(args.queryClient);
  const mutationKey = getMutationKeyInternal(path);
  const defaultOpts = queryClient.defaultMutationOptions(queryClient.getMutationDefaults(mutationKey));
  const mutationSuccessOverride = (overrides == null ? void 0 : overrides.onSuccess) ?? ((options) => options.originalFn());
  const mutationFn = async (input) => {
    const result = await mutate(...getClientArgs([
      path,
      {
        input
      }
    ], opts));
    return result;
  };
  return {
    ...opts,
    mutationKey,
    mutationFn,
    onSuccess(...args2) {
      const originalFn = () => {
        var _a2, _b2;
        return ((_a2 = opts == null ? void 0 : opts.onSuccess) == null ? void 0 : _a2.call(opts, ...args2)) ?? ((_b2 = defaultOpts == null ? void 0 : defaultOpts.onSuccess) == null ? void 0 : _b2.call(defaultOpts, ...args2));
      };
      return mutationSuccessOverride({
        originalFn,
        queryClient,
        meta: (opts == null ? void 0 : opts.meta) ?? (defaultOpts == null ? void 0 : defaultOpts.meta) ?? {}
      });
    },
    trpc: createTRPCOptionsResult({
      path
    })
  };
}

// node_modules/@trpc/tanstack-react-query/dist/internals/queryOptions.mjs
function trpcQueryOptions(args) {
  const { input, query, path, queryKey, opts } = args;
  const queryClient = unwrapLazyArg(args.queryClient);
  const inputIsSkipToken = input === skipToken;
  const queryFn = async (queryFnContext) => {
    var _a2;
    const actualOpts = {
      ...opts,
      trpc: {
        ...opts == null ? void 0 : opts.trpc,
        ...((_a2 = opts == null ? void 0 : opts.trpc) == null ? void 0 : _a2.abortOnUnmount) ? {
          signal: queryFnContext.signal
        } : {
          signal: null
        }
      }
    };
    const result = await query(...getClientArgs(queryKey, actualOpts));
    if (isAsyncIterable(result)) {
      return buildQueryFromAsyncIterable(result, queryClient, queryKey);
    }
    return result;
  };
  return Object.assign(queryOptions({
    ...opts,
    queryKey,
    queryFn: inputIsSkipToken ? skipToken : queryFn
  }), {
    trpc: createTRPCOptionsResult({
      path
    })
  });
}

// node_modules/@trpc/tanstack-react-query/dist/internals/subscriptionOptions.mjs
var React = __toESM(require_react(), 1);
var trpcSubscriptionOptions = (args) => {
  var _a2;
  const { subscribe, path, queryKey, opts } = args;
  const input = (_a2 = queryKey[1]) == null ? void 0 : _a2.input;
  const enabled = "enabled" in opts ? !!opts.enabled : input !== skipToken;
  const _subscribe = (innerOpts) => {
    return subscribe(path.join("."), input ?? void 0, innerOpts);
  };
  return {
    ...opts,
    enabled,
    subscribe: _subscribe,
    queryKey,
    trpc: createTRPCOptionsResult({
      path
    })
  };
};
function useSubscription(opts) {
  const optsRef = React.useRef(opts);
  optsRef.current = opts;
  const trackedProps = React.useRef(/* @__PURE__ */ new Set([]));
  const addTrackedProp = React.useCallback((key) => {
    trackedProps.current.add(key);
  }, []);
  const currentSubscriptionRef = React.useRef(() => {
  });
  const reset = React.useCallback(() => {
    var _a2;
    (_a2 = currentSubscriptionRef.current) == null ? void 0 : _a2.call(currentSubscriptionRef);
    updateState(getInitialState);
    if (!opts.enabled) {
      return;
    }
    const subscription = opts.subscribe({
      onStarted: () => {
        var _a3, _b2;
        (_b2 = (_a3 = optsRef.current).onStarted) == null ? void 0 : _b2.call(_a3);
        updateState((prev) => ({
          ...prev,
          status: "pending",
          error: null
        }));
      },
      onData: (data) => {
        var _a3, _b2;
        (_b2 = (_a3 = optsRef.current).onData) == null ? void 0 : _b2.call(_a3, data);
        updateState((prev) => ({
          ...prev,
          status: "pending",
          data,
          error: null
        }));
      },
      onError: (error) => {
        var _a3, _b2;
        (_b2 = (_a3 = optsRef.current).onError) == null ? void 0 : _b2.call(_a3, error);
        updateState((prev) => ({
          ...prev,
          status: "error",
          error
        }));
      },
      onConnectionStateChange: (result) => {
        updateState((prev) => {
          switch (result.state) {
            case "connecting":
              return {
                ...prev,
                status: "connecting",
                error: result.error
              };
            case "pending":
              return prev;
            case "idle":
              return {
                ...prev,
                status: "idle",
                data: void 0,
                error: null
              };
          }
        });
      }
    });
    currentSubscriptionRef.current = () => {
      subscription.unsubscribe();
    };
  }, [
    hashKey(opts.queryKey),
    opts.enabled
  ]);
  const getInitialState = React.useCallback(() => {
    return opts.enabled ? {
      data: void 0,
      error: null,
      status: "connecting",
      reset
    } : {
      data: void 0,
      error: null,
      status: "idle",
      reset
    };
  }, [
    opts.enabled,
    reset
  ]);
  const resultRef = React.useRef(getInitialState());
  const [state, setState] = React.useState(trackResult(resultRef.current, addTrackedProp));
  state.reset = reset;
  const updateState = React.useCallback((callback) => {
    const prev = resultRef.current;
    const next = resultRef.current = callback(prev);
    let shouldUpdate = false;
    for (const key of trackedProps.current) {
      if (prev[key] !== next[key]) {
        shouldUpdate = true;
        break;
      }
    }
    if (shouldUpdate) {
      setState(trackResult(next, addTrackedProp));
    }
  }, [
    addTrackedProp
  ]);
  React.useEffect(() => {
    if (!opts.enabled) {
      return;
    }
    reset();
    return () => {
      var _a2;
      (_a2 = currentSubscriptionRef.current) == null ? void 0 : _a2.call(currentSubscriptionRef);
    };
  }, [
    reset,
    opts.enabled
  ]);
  return state;
}
function trackResult(result, onTrackResult) {
  const trackedResult = new Proxy(result, {
    get(target, prop) {
      onTrackResult(prop);
      return target[prop];
    }
  });
  return trackedResult;
}

// node_modules/@trpc/tanstack-react-query/dist/internals/createOptionsProxy.mjs
function createTRPCOptionsProxy(opts) {
  const callIt = (type) => {
    return (path, input, trpcOpts) => {
      if ("router" in opts) {
        return Promise.resolve(unwrapLazyArg(opts.ctx)).then((ctx) => callProcedure({
          router: opts.router,
          path,
          getRawInput: async () => input,
          ctx,
          type,
          signal: void 0
        }));
      }
      const untypedClient = opts.client instanceof TRPCUntypedClient ? opts.client : getUntypedClient(opts.client);
      return untypedClient[type](path, input, trpcOpts);
    };
  };
  return createRecursiveProxy(({ args, path: _path }) => {
    const path = [
      ..._path
    ];
    const utilName = path.pop();
    const [arg1, arg2] = args;
    const contextMap = {
      "~types": void 0,
      pathKey: () => {
        return getQueryKeyInternal(path);
      },
      pathFilter: () => {
        return {
          ...arg1,
          queryKey: getQueryKeyInternal(path)
        };
      },
      queryOptions: () => {
        return trpcQueryOptions({
          input: arg1,
          opts: arg2,
          path,
          queryClient: opts.queryClient,
          queryKey: getQueryKeyInternal(path, arg1, "query"),
          query: callIt("query")
        });
      },
      queryKey: () => {
        return getQueryKeyInternal(path, arg1, "query");
      },
      queryFilter: () => {
        return {
          ...arg2,
          queryKey: getQueryKeyInternal(path, arg1, "query")
        };
      },
      infiniteQueryOptions: () => {
        return trpcInfiniteQueryOptions({
          input: arg1,
          opts: arg2,
          path,
          queryClient: opts.queryClient,
          queryKey: getQueryKeyInternal(path, arg1, "infinite"),
          query: callIt("query")
        });
      },
      infiniteQueryKey: () => {
        return getQueryKeyInternal(path, arg1, "infinite");
      },
      infiniteQueryFilter: () => {
        return {
          ...arg2,
          queryKey: getQueryKeyInternal(path, arg1, "infinite")
        };
      },
      mutationOptions: () => {
        var _a2;
        return trpcMutationOptions({
          opts: arg1,
          path,
          queryClient: opts.queryClient,
          mutate: callIt("mutation"),
          overrides: (_a2 = opts.overrides) == null ? void 0 : _a2.mutations
        });
      },
      mutationKey: () => {
        return getMutationKeyInternal(path);
      },
      subscriptionOptions: () => {
        return trpcSubscriptionOptions({
          opts: arg2,
          path,
          queryKey: getQueryKeyInternal(path, arg1, "any"),
          subscribe: callIt("subscription")
        });
      }
    };
    return contextMap[utilName]();
  });
}

// node_modules/@trpc/tanstack-react-query/dist/internals/Context.mjs
function createTRPCContext() {
  const TRPCClientContext = React2.createContext(null);
  const TRPCContext = React2.createContext(null);
  function TRPCProvider(props) {
    const value = React2.useMemo(() => createTRPCOptionsProxy({
      client: props.trpcClient,
      queryClient: props.queryClient
    }), [
      props.trpcClient,
      props.queryClient
    ]);
    return React2.createElement(TRPCClientContext.Provider, {
      value: props.trpcClient
    }, React2.createElement(TRPCContext.Provider, {
      value
    }, props.children));
  }
  function useTRPC() {
    const utils = React2.useContext(TRPCContext);
    if (!utils) {
      throw new Error("useTRPC() can only be used inside of a <TRPCProvider>");
    }
    return utils;
  }
  function useTRPCClient() {
    const client = React2.useContext(TRPCClientContext);
    if (!client) {
      throw new Error("useTRPCClient() can only be used inside of a <TRPCProvider>");
    }
    return client;
  }
  return {
    TRPCProvider,
    useTRPC,
    useTRPCClient
  };
}
export {
  createTRPCContext,
  createTRPCOptionsProxy,
  useSubscription
};
/*! Bundled license information:

@trpc/server/dist/unstable-core-do-not-import/router.mjs:
  (* istanbul ignore if -- @preserve *)

@trpc/server/dist/unstable-core-do-not-import/rpc/parseTRPCMessage.mjs:
  (* istanbul ignore next -- @preserve *)

@trpc/server/dist/unstable-core-do-not-import/rpc/parseTRPCMessage.mjs:
  (* istanbul ignore next -- @preserve *)

@trpc/server/dist/unstable-core-do-not-import/rpc/parseTRPCMessage.mjs:
  (* istanbul ignore next -- @preserve *)

@trpc/server/dist/unstable-core-do-not-import/rpc/parseTRPCMessage.mjs:
  (* istanbul ignore next -- @preserve *)

@trpc/server/dist/unstable-core-do-not-import/rpc/parseTRPCMessage.mjs:
  (* istanbul ignore next -- @preserve *)

@trpc/client/dist/links/retryLink.mjs:
  (* istanbul ignore file -- @preserve *)
*/
//# sourceMappingURL=@trpc_tanstack-react-query.js.map
