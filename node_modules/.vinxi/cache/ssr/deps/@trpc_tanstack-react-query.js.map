{
  "version": 3,
  "sources": ["../../../../@trpc/tanstack-react-query/dist/internals/Context.mjs", "../../../../@trpc/server/dist/observable/observable.mjs", "../../../../@trpc/server/dist/observable/operators.mjs", "../../../../@trpc/server/dist/observable/behaviorSubject.mjs", "../../../../@trpc/client/dist/links/internals/createChain.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/createProxy.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/error/formatter.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/rpc/codes.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/utils.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/error/TRPCError.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/transformer.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/router.mjs", "../../../../@trpc/server/dist/vendor/unpromise/unpromise.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/stream/utils/disposable.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/stream/utils/timerResource.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/stream/utils/withPing.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/stream/tracked.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/middleware.mjs", "../../../../@trpc/server/dist/vendor/standard-schema-v1/error.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/parser.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/procedureBuilder.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/rootConfig.mjs", "../../../../@trpc/server/dist/unstable-core-do-not-import/initTRPC.mjs", "../../../../@trpc/client/dist/TRPCClientError.mjs", "../../../../@trpc/client/dist/internals/TRPCUntypedClient.mjs", "../../../../@trpc/client/dist/createTRPCClient.mjs", "../../../../@trpc/client/dist/links/internals/urlWithConnectionParams.mjs", "../../../../@trpc/client/dist/links/wsLink/wsClient/utils.mjs", "../../../../@trpc/client/dist/links/wsLink/wsClient/wsConnection.mjs", "../../../../@trpc/client/dist/links/httpSubscriptionLink.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/utils.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/infiniteQueryOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/mutationOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/queryOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/subscriptionOptions.mjs", "../../../../@trpc/tanstack-react-query/dist/internals/createOptionsProxy.mjs"],
  "sourcesContent": ["import * as React from 'react';\nimport { createTRPCOptionsProxy } from './createOptionsProxy.mjs';\n\n/**\n * Create a set of type-safe provider-consumers\n *\n * @see https://trpc.io/docs/client/tanstack-react-query/setup#3a-setup-the-trpc-context-provider\n */ function createTRPCContext() {\n    const TRPCClientContext = /*#__PURE__*/ React.createContext(null);\n    const TRPCContext = /*#__PURE__*/ React.createContext(null);\n    function TRPCProvider(props) {\n        const value = React.useMemo(()=>createTRPCOptionsProxy({\n                client: props.trpcClient,\n                queryClient: props.queryClient\n            }), [\n            props.trpcClient,\n            props.queryClient\n        ]);\n        return /*#__PURE__*/ React.createElement(TRPCClientContext.Provider, {\n            value: props.trpcClient\n        }, /*#__PURE__*/ React.createElement(TRPCContext.Provider, {\n            value: value\n        }, props.children));\n    }\n    function useTRPC() {\n        const utils = React.useContext(TRPCContext);\n        if (!utils) {\n            throw new Error('useTRPC() can only be used inside of a <TRPCProvider>');\n        }\n        return utils;\n    }\n    function useTRPCClient() {\n        const client = React.useContext(TRPCClientContext);\n        if (!client) {\n            throw new Error('useTRPCClient() can only be used inside of a <TRPCProvider>');\n        }\n        return client;\n    }\n    return {\n        TRPCProvider,\n        useTRPC,\n        useTRPCClient\n    };\n}\n\nexport { createTRPCContext };\n", "/** @public */ function isObservable(x) {\n    return typeof x === 'object' && x !== null && 'subscribe' in x;\n}\n/** @public */ function observable(subscribe) {\n    const self = {\n        subscribe (observer) {\n            let teardownRef = null;\n            let isDone = false;\n            let unsubscribed = false;\n            let teardownImmediately = false;\n            function unsubscribe() {\n                if (teardownRef === null) {\n                    teardownImmediately = true;\n                    return;\n                }\n                if (unsubscribed) {\n                    return;\n                }\n                unsubscribed = true;\n                if (typeof teardownRef === 'function') {\n                    teardownRef();\n                } else if (teardownRef) {\n                    teardownRef.unsubscribe();\n                }\n            }\n            teardownRef = subscribe({\n                next (value) {\n                    if (isDone) {\n                        return;\n                    }\n                    observer.next?.(value);\n                },\n                error (err) {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.error?.(err);\n                    unsubscribe();\n                },\n                complete () {\n                    if (isDone) {\n                        return;\n                    }\n                    isDone = true;\n                    observer.complete?.();\n                    unsubscribe();\n                }\n            });\n            if (teardownImmediately) {\n                unsubscribe();\n            }\n            return {\n                unsubscribe\n            };\n        },\n        pipe (...operations) {\n            return operations.reduce(pipeReducer, self);\n        }\n    };\n    return self;\n}\nfunction pipeReducer(prev, fn) {\n    return fn(prev);\n}\n/** @internal */ function observableToPromise(observable) {\n    const ac = new AbortController();\n    const promise = new Promise((resolve, reject)=>{\n        let isDone = false;\n        function onDone() {\n            if (isDone) {\n                return;\n            }\n            isDone = true;\n            obs$.unsubscribe();\n        }\n        ac.signal.addEventListener('abort', ()=>{\n            reject(ac.signal.reason);\n        });\n        const obs$ = observable.subscribe({\n            next (data) {\n                isDone = true;\n                resolve(data);\n                onDone();\n            },\n            error (data) {\n                reject(data);\n            },\n            complete () {\n                ac.abort();\n                onDone();\n            }\n        });\n    });\n    return promise;\n}\n/**\n * @internal\n */ function observableToReadableStream(observable, signal) {\n    let unsub = null;\n    const onAbort = ()=>{\n        unsub?.unsubscribe();\n        unsub = null;\n        signal.removeEventListener('abort', onAbort);\n    };\n    return new ReadableStream({\n        start (controller) {\n            unsub = observable.subscribe({\n                next (data) {\n                    controller.enqueue({\n                        ok: true,\n                        value: data\n                    });\n                },\n                error (error) {\n                    controller.enqueue({\n                        ok: false,\n                        error\n                    });\n                    controller.close();\n                },\n                complete () {\n                    controller.close();\n                }\n            });\n            if (signal.aborted) {\n                onAbort();\n            } else {\n                signal.addEventListener('abort', onAbort, {\n                    once: true\n                });\n            }\n        },\n        cancel () {\n            onAbort();\n        }\n    });\n}\n/** @internal */ function observableToAsyncIterable(observable, signal) {\n    const stream = observableToReadableStream(observable, signal);\n    const reader = stream.getReader();\n    const iterator = {\n        async next () {\n            const value = await reader.read();\n            if (value.done) {\n                return {\n                    value: undefined,\n                    done: true\n                };\n            }\n            const { value: result } = value;\n            if (!result.ok) {\n                throw result.error;\n            }\n            return {\n                value: result.value,\n                done: false\n            };\n        },\n        async return () {\n            await reader.cancel();\n            return {\n                value: undefined,\n                done: true\n            };\n        }\n    };\n    return {\n        [Symbol.asyncIterator] () {\n            return iterator;\n        }\n    };\n}\n\nexport { isObservable, observable, observableToAsyncIterable, observableToPromise };\n", "import { observable } from './observable.mjs';\n\nfunction map(project) {\n    return (source)=>{\n        return observable((destination)=>{\n            let index = 0;\n            const subscription = source.subscribe({\n                next (value) {\n                    destination.next(project(value, index++));\n                },\n                error (error) {\n                    destination.error(error);\n                },\n                complete () {\n                    destination.complete();\n                }\n            });\n            return subscription;\n        });\n    };\n}\nfunction share(_opts) {\n    return (source)=>{\n        let refCount = 0;\n        let subscription = null;\n        const observers = [];\n        function startIfNeeded() {\n            if (subscription) {\n                return;\n            }\n            subscription = source.subscribe({\n                next (value) {\n                    for (const observer of observers){\n                        observer.next?.(value);\n                    }\n                },\n                error (error) {\n                    for (const observer of observers){\n                        observer.error?.(error);\n                    }\n                },\n                complete () {\n                    for (const observer of observers){\n                        observer.complete?.();\n                    }\n                }\n            });\n        }\n        function resetIfNeeded() {\n            // \"resetOnRefCountZero\"\n            if (refCount === 0 && subscription) {\n                const _sub = subscription;\n                subscription = null;\n                _sub.unsubscribe();\n            }\n        }\n        return observable((subscriber)=>{\n            refCount++;\n            observers.push(subscriber);\n            startIfNeeded();\n            return {\n                unsubscribe () {\n                    refCount--;\n                    resetIfNeeded();\n                    const index = observers.findIndex((v)=>v === subscriber);\n                    if (index > -1) {\n                        observers.splice(index, 1);\n                    }\n                }\n            };\n        });\n    };\n}\nfunction tap(observer) {\n    return (source)=>{\n        return observable((destination)=>{\n            return source.subscribe({\n                next (value) {\n                    observer.next?.(value);\n                    destination.next(value);\n                },\n                error (error) {\n                    observer.error?.(error);\n                    destination.error(error);\n                },\n                complete () {\n                    observer.complete?.();\n                    destination.complete();\n                }\n            });\n        });\n    };\n}\nconst distinctUnsetMarker = Symbol();\nfunction distinctUntilChanged(compare = (a, b)=>a === b) {\n    return (source)=>{\n        return observable((destination)=>{\n            let lastValue = distinctUnsetMarker;\n            return source.subscribe({\n                next (value) {\n                    if (lastValue !== distinctUnsetMarker && compare(lastValue, value)) {\n                        return;\n                    }\n                    lastValue = value;\n                    destination.next(value);\n                },\n                error (error) {\n                    destination.error(error);\n                },\n                complete () {\n                    destination.complete();\n                }\n            });\n        });\n    };\n}\nconst isDeepEqual = (a, b)=>{\n    if (a === b) {\n        return true;\n    }\n    const bothAreObjects = a && b && typeof a === 'object' && typeof b === 'object';\n    return !!bothAreObjects && Object.keys(a).length === Object.keys(b).length && Object.entries(a).every(([k, v])=>isDeepEqual(v, b[k]));\n};\nfunction distinctUntilDeepChanged() {\n    return distinctUntilChanged(isDeepEqual);\n}\n\nexport { distinctUntilChanged, distinctUntilDeepChanged, map, share, tap };\n", "import { observable } from './observable.mjs';\n\n/**\n * @internal\n * An observable that maintains and provides a \"current value\" to subscribers\n * @see https://www.learnrxjs.io/learn-rxjs/subjects/behaviorsubject\n */ function behaviorSubject(initialValue) {\n    let value = initialValue;\n    const observerList = [];\n    const addObserver = (observer)=>{\n        if (value !== undefined) {\n            observer.next(value);\n        }\n        observerList.push(observer);\n    };\n    const removeObserver = (observer)=>{\n        observerList.splice(observerList.indexOf(observer), 1);\n    };\n    const obs = observable((observer)=>{\n        addObserver(observer);\n        return ()=>{\n            removeObserver(observer);\n        };\n    });\n    obs.next = (nextValue)=>{\n        if (value === nextValue) {\n            return;\n        }\n        value = nextValue;\n        for (const observer of observerList){\n            observer.next(nextValue);\n        }\n    };\n    obs.get = ()=>value;\n    return obs;\n}\n\nexport { behaviorSubject };\n", "import { observable } from '@trpc/server/observable';\n\n/** @internal */ function createChain(opts) {\n    return observable((observer)=>{\n        function execute(index = 0, op = opts.op) {\n            const next = opts.links[index];\n            if (!next) {\n                throw new Error('No more links to execute - did you forget to add an ending link?');\n            }\n            const subscription = next({\n                op,\n                next (nextOp) {\n                    const nextObserver = execute(index + 1, nextOp);\n                    return nextObserver;\n                }\n            });\n            return subscription;\n        }\n        const obs$ = execute();\n        return obs$.subscribe(observer);\n    });\n}\n\nexport { createChain };\n", "const noop = ()=>{\n// noop\n};\nconst freezeIfAvailable = (obj)=>{\n    if (Object.freeze) {\n        Object.freeze(obj);\n    }\n};\nfunction createInnerProxy(callback, path, memo) {\n    var _memo, _cacheKey;\n    const cacheKey = path.join('.');\n    (_memo = memo)[_cacheKey = cacheKey] ?? (_memo[_cacheKey] = new Proxy(noop, {\n        get (_obj, key) {\n            if (typeof key !== 'string' || key === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return createInnerProxy(callback, [\n                ...path,\n                key\n            ], memo);\n        },\n        apply (_1, _2, args) {\n            const lastOfPath = path[path.length - 1];\n            let opts = {\n                args,\n                path\n            };\n            // special handling for e.g. `trpc.hello.call(this, 'there')` and `trpc.hello.apply(this, ['there'])\n            if (lastOfPath === 'call') {\n                opts = {\n                    args: args.length >= 2 ? [\n                        args[1]\n                    ] : [],\n                    path: path.slice(0, -1)\n                };\n            } else if (lastOfPath === 'apply') {\n                opts = {\n                    args: args.length >= 2 ? args[1] : [],\n                    path: path.slice(0, -1)\n                };\n            }\n            freezeIfAvailable(opts.args);\n            freezeIfAvailable(opts.path);\n            return callback(opts);\n        }\n    }));\n    return memo[cacheKey];\n}\n/**\n * Creates a proxy that calls the callback with the path and arguments\n *\n * @internal\n */ const createRecursiveProxy = (callback)=>createInnerProxy(callback, [], Object.create(null));\n/**\n * Used in place of `new Proxy` where each handler will map 1 level deep to another value.\n *\n * @internal\n */ const createFlatProxy = (callback)=>{\n    return new Proxy(noop, {\n        get (_obj, name) {\n            if (name === 'then') {\n                // special case for if the proxy is accidentally treated\n                // like a PromiseLike (like in `Promise.resolve(proxy)`)\n                return undefined;\n            }\n            return callback(name);\n        }\n    });\n};\n\nexport { createFlatProxy, createRecursiveProxy };\n", "const defaultFormatter = ({ shape })=>{\n    return shape;\n};\n\nexport { defaultFormatter };\n", "// reference: https://www.jsonrpc.org/specification\n/**\n * JSON-RPC 2.0 Error codes\n *\n * `-32000` to `-32099` are reserved for implementation-defined server-errors.\n * For tRPC we're copying the last digits of HTTP 4XX errors.\n */ const TRPC_ERROR_CODES_BY_KEY = {\n    /**\n   * Invalid JSON was received by the server.\n   * An error occurred on the server while parsing the JSON text.\n   */ PARSE_ERROR: -32700,\n    /**\n   * The JSON sent is not a valid Request object.\n   */ BAD_REQUEST: -32600,\n    // Internal JSON-RPC error\n    INTERNAL_SERVER_ERROR: -32603,\n    NOT_IMPLEMENTED: -32603,\n    BAD_GATEWAY: -32603,\n    SERVICE_UNAVAILABLE: -32603,\n    GATEWAY_TIMEOUT: -32603,\n    // Implementation specific errors\n    UNAUTHORIZED: -32001,\n    FORBIDDEN: -32003,\n    NOT_FOUND: -32004,\n    METHOD_NOT_SUPPORTED: -32005,\n    TIMEOUT: -32008,\n    CONFLICT: -32009,\n    PRECONDITION_FAILED: -32012,\n    PAYLOAD_TOO_LARGE: -32013,\n    UNSUPPORTED_MEDIA_TYPE: -32015,\n    UNPROCESSABLE_CONTENT: -32022,\n    TOO_MANY_REQUESTS: -32029,\n    CLIENT_CLOSED_REQUEST: -32099\n};\n// pure\nconst TRPC_ERROR_CODES_BY_NUMBER = {\n    [-32700]: 'PARSE_ERROR',\n    [-32600]: 'BAD_REQUEST',\n    [-32603]: 'INTERNAL_SERVER_ERROR',\n    [-32001]: 'UNAUTHORIZED',\n    [-32003]: 'FORBIDDEN',\n    [-32004]: 'NOT_FOUND',\n    [-32005]: 'METHOD_NOT_SUPPORTED',\n    [-32008]: 'TIMEOUT',\n    [-32009]: 'CONFLICT',\n    [-32012]: 'PRECONDITION_FAILED',\n    [-32013]: 'PAYLOAD_TOO_LARGE',\n    [-32015]: 'UNSUPPORTED_MEDIA_TYPE',\n    [-32022]: 'UNPROCESSABLE_CONTENT',\n    [-32029]: 'TOO_MANY_REQUESTS',\n    [-32099]: 'CLIENT_CLOSED_REQUEST'\n};\n\nexport { TRPC_ERROR_CODES_BY_KEY, TRPC_ERROR_CODES_BY_NUMBER };\n", "/** @internal */ const unsetMarker = Symbol();\n/**\n * Ensures there are no duplicate keys when building a procedure.\n * @internal\n */ function mergeWithoutOverrides(obj1, ...objs) {\n    const newObj = Object.assign(Object.create(null), obj1);\n    for (const overrides of objs){\n        for(const key in overrides){\n            if (key in newObj && newObj[key] !== overrides[key]) {\n                throw new Error(`Duplicate key ${key}`);\n            }\n            newObj[key] = overrides[key];\n        }\n    }\n    return newObj;\n}\n/**\n * Check that value is object\n * @internal\n */ function isObject(value) {\n    return !!value && !Array.isArray(value) && typeof value === 'object';\n}\nfunction isFunction(fn) {\n    return typeof fn === 'function';\n}\n/**\n * Create an object without inheriting anything from `Object.prototype`\n * @internal\n */ function omitPrototype(obj) {\n    return Object.assign(Object.create(null), obj);\n}\nconst asyncIteratorsSupported = typeof Symbol === 'function' && !!Symbol.asyncIterator;\nfunction isAsyncIterable(value) {\n    return asyncIteratorsSupported && isObject(value) && Symbol.asyncIterator in value;\n}\n/**\n * Run an IIFE\n */ const run = (fn)=>fn();\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() {}\nfunction identity(it) {\n    return it;\n}\n/**\n * Generic runtime assertion function. Throws, if the condition is not `true`.\n *\n * Can be used as a slightly less dangerous variant of type assertions. Code\n * mistakes would be revealed at runtime then (hopefully during testing).\n */ function assert(condition, msg = 'no additional info') {\n    if (!condition) {\n        throw new Error(`AssertionError: ${msg}`);\n    }\n}\nfunction sleep(ms = 0) {\n    return new Promise((res)=>setTimeout(res, ms));\n}\n/**\n * Ponyfill for\n * [`AbortSignal.any`](https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/any_static).\n */ function abortSignalsAnyPonyfill(signals) {\n    if (typeof AbortSignal.any === 'function') {\n        return AbortSignal.any(signals);\n    }\n    const ac = new AbortController();\n    for (const signal of signals){\n        if (signal.aborted) {\n            trigger();\n            break;\n        }\n        signal.addEventListener('abort', trigger, {\n            once: true\n        });\n    }\n    return ac.signal;\n    function trigger() {\n        ac.abort();\n        for (const signal of signals){\n            signal.removeEventListener('abort', trigger);\n        }\n    }\n}\n\nexport { abortSignalsAnyPonyfill, assert, identity, isAsyncIterable, isFunction, isObject, mergeWithoutOverrides, noop, omitPrototype, run, sleep, unsetMarker };\n", "import { isObject } from '../utils.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass UnknownCauseError extends Error {\n}\nfunction getCauseFromUnknown(cause) {\n    if (cause instanceof Error) {\n        return cause;\n    }\n    const type = typeof cause;\n    if (type === 'undefined' || type === 'function' || cause === null) {\n        return undefined;\n    }\n    // Primitive types just get wrapped in an error\n    if (type !== 'object') {\n        // eslint-disable-next-line @typescript-eslint/no-base-to-string\n        return new Error(String(cause));\n    }\n    // If it's an object, we'll create a synthetic error\n    if (isObject(cause)) {\n        const err = new UnknownCauseError();\n        for(const key in cause){\n            err[key] = cause[key];\n        }\n        return err;\n    }\n    return undefined;\n}\nfunction getTRPCErrorFromUnknown(cause) {\n    if (cause instanceof TRPCError) {\n        return cause;\n    }\n    if (cause instanceof Error && cause.name === 'TRPCError') {\n        // https://github.com/trpc/trpc/pull/4848\n        return cause;\n    }\n    const trpcError = new TRPCError({\n        code: 'INTERNAL_SERVER_ERROR',\n        cause\n    });\n    // Inherit stack from error\n    if (cause instanceof Error && cause.stack) {\n        trpcError.stack = cause.stack;\n    }\n    return trpcError;\n}\nclass TRPCError extends Error {\n    constructor(opts){\n        const cause = getCauseFromUnknown(opts.cause);\n        const message = opts.message ?? cause?.message ?? opts.code;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        }), // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n        _define_property(this, \"cause\", void 0), _define_property(this, \"code\", void 0);\n        this.code = opts.code;\n        this.name = 'TRPCError';\n        if (!this.cause) {\n            // < ES2022 / < Node 16.9.0 compatability\n            this.cause = cause;\n        }\n    }\n}\n\nexport { TRPCError, getCauseFromUnknown, getTRPCErrorFromUnknown };\n", "import { isObject } from './utils.mjs';\n\n/**\n * @internal\n */ function getDataTransformer(transformer) {\n    if ('input' in transformer) {\n        return transformer;\n    }\n    return {\n        input: transformer,\n        output: transformer\n    };\n}\n/**\n * @internal\n */ const defaultTransformer = {\n    input: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    },\n    output: {\n        serialize: (obj)=>obj,\n        deserialize: (obj)=>obj\n    }\n};\nfunction transformTRPCResponseItem(config, item) {\n    if ('error' in item) {\n        return {\n            ...item,\n            error: config.transformer.output.serialize(item.error)\n        };\n    }\n    if ('data' in item.result) {\n        return {\n            ...item,\n            result: {\n                ...item.result,\n                data: config.transformer.output.serialize(item.result.data)\n            }\n        };\n    }\n    return item;\n}\n/**\n * Takes a unserialized `TRPCResponse` and serializes it with the router's transformers\n **/ function transformTRPCResponse(config, itemOrItems) {\n    return Array.isArray(itemOrItems) ? itemOrItems.map((item)=>transformTRPCResponseItem(config, item)) : transformTRPCResponseItem(config, itemOrItems);\n}\n// FIXME:\n// - the generics here are probably unnecessary\n// - the RPC-spec could probably be simplified to combine HTTP + WS\n/** @internal */ function transformResultInner(response, transformer) {\n    if ('error' in response) {\n        const error = transformer.deserialize(response.error);\n        return {\n            ok: false,\n            error: {\n                ...response,\n                error\n            }\n        };\n    }\n    const result = {\n        ...response.result,\n        ...(!response.result.type || response.result.type === 'data') && {\n            type: 'data',\n            data: transformer.deserialize(response.result.data)\n        }\n    };\n    return {\n        ok: true,\n        result\n    };\n}\nclass TransformResultError extends Error {\n    constructor(){\n        super('Unable to transform response from server');\n    }\n}\n/**\n * Transforms and validates that the result is a valid TRPCResponse\n * @internal\n */ function transformResult(response, transformer) {\n    let result;\n    try {\n        // Use the data transformers on the JSON-response\n        result = transformResultInner(response, transformer);\n    } catch  {\n        throw new TransformResultError();\n    }\n    // check that output of the transformers is a valid TRPCResponse\n    if (!result.ok && (!isObject(result.error.error) || typeof result.error.error['code'] !== 'number')) {\n        throw new TransformResultError();\n    }\n    if (result.ok && !isObject(result.result)) {\n        throw new TransformResultError();\n    }\n    return result;\n}\n\nexport { defaultTransformer, getDataTransformer, transformResult, transformTRPCResponse };\n", "import { createRecursiveProxy } from './createProxy.mjs';\nimport { defaultFormatter } from './error/formatter.mjs';\nimport { TRPCError, getTRPCErrorFromUnknown } from './error/TRPCError.mjs';\nimport { defaultTransformer } from './transformer.mjs';\nimport { mergeWithoutOverrides, omitPrototype, isObject, isFunction } from './utils.mjs';\n\nconst lazySymbol = Symbol('lazy');\nfunction once(fn) {\n    const uncalled = Symbol();\n    let result = uncalled;\n    return ()=>{\n        if (result === uncalled) {\n            result = fn();\n        }\n        return result;\n    };\n}\n/**\n * Lazy load a router\n * @see https://trpc.io/docs/server/merging-routers#lazy-load\n */ function lazy(importRouter) {\n    async function resolve() {\n        const mod = await importRouter();\n        // if the module is a router, return it\n        if (isRouter(mod)) {\n            return mod;\n        }\n        const routers = Object.values(mod);\n        if (routers.length !== 1 || !isRouter(routers[0])) {\n            throw new Error(\"Invalid router module - either define exactly 1 export or return the router directly.\\nExample: `lazy(() => import('./slow.js').then((m) => m.slowRouter))`\");\n        }\n        return routers[0];\n    }\n    resolve[lazySymbol] = true;\n    return resolve;\n}\nfunction isLazy(input) {\n    return typeof input === 'function' && lazySymbol in input;\n}\nfunction isRouter(value) {\n    return isObject(value) && isObject(value['_def']) && 'router' in value['_def'];\n}\nconst emptyRouter = {\n    _ctx: null,\n    _errorShape: null,\n    _meta: null,\n    queries: {},\n    mutations: {},\n    subscriptions: {},\n    errorFormatter: defaultFormatter,\n    transformer: defaultTransformer\n};\n/**\n * Reserved words that can't be used as router or procedure names\n */ const reservedWords = [\n    /**\n   * Then is a reserved word because otherwise we can't return a promise that returns a Proxy\n   * since JS will think that `.then` is something that exists\n   */ 'then',\n    /**\n   * `fn.call()` and `fn.apply()` are reserved words because otherwise we can't call a function using `.call` or `.apply`\n   */ 'call',\n    'apply'\n];\n/**\n * @internal\n */ function createRouterFactory(config) {\n    function createRouterInner(input) {\n        const reservedWordsUsed = new Set(Object.keys(input).filter((v)=>reservedWords.includes(v)));\n        if (reservedWordsUsed.size > 0) {\n            throw new Error('Reserved words used in `router({})` call: ' + Array.from(reservedWordsUsed).join(', '));\n        }\n        const procedures = omitPrototype({});\n        const lazy = omitPrototype({});\n        function createLazyLoader(opts) {\n            return {\n                ref: opts.ref,\n                load: once(async ()=>{\n                    const router = await opts.ref();\n                    const lazyPath = [\n                        ...opts.path,\n                        opts.key\n                    ];\n                    const lazyKey = lazyPath.join('.');\n                    opts.aggregate[opts.key] = step(router._def.record, lazyPath);\n                    delete lazy[lazyKey];\n                    // add lazy loaders for nested routers\n                    for (const [nestedKey, nestedItem] of Object.entries(router._def.lazy)){\n                        const nestedRouterKey = [\n                            ...lazyPath,\n                            nestedKey\n                        ].join('.');\n                        // console.log('adding lazy', nestedRouterKey);\n                        lazy[nestedRouterKey] = createLazyLoader({\n                            ref: nestedItem.ref,\n                            path: lazyPath,\n                            key: nestedKey,\n                            aggregate: opts.aggregate[opts.key]\n                        });\n                    }\n                })\n            };\n        }\n        function step(from, path = []) {\n            const aggregate = omitPrototype({});\n            for (const [key, item] of Object.entries(from ?? {})){\n                if (isLazy(item)) {\n                    lazy[[\n                        ...path,\n                        key\n                    ].join('.')] = createLazyLoader({\n                        path,\n                        ref: item,\n                        key,\n                        aggregate\n                    });\n                    continue;\n                }\n                if (isRouter(item)) {\n                    aggregate[key] = step(item._def.record, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                if (!isProcedure(item)) {\n                    // RouterRecord\n                    aggregate[key] = step(item, [\n                        ...path,\n                        key\n                    ]);\n                    continue;\n                }\n                const newPath = [\n                    ...path,\n                    key\n                ].join('.');\n                if (procedures[newPath]) {\n                    throw new Error(`Duplicate key: ${newPath}`);\n                }\n                procedures[newPath] = item;\n                aggregate[key] = item;\n            }\n            return aggregate;\n        }\n        const record = step(input);\n        const _def = {\n            _config: config,\n            router: true,\n            procedures,\n            lazy,\n            ...emptyRouter,\n            record\n        };\n        const router = {\n            ...record,\n            _def,\n            createCaller: createCallerFactory()({\n                _def\n            })\n        };\n        return router;\n    }\n    return createRouterInner;\n}\nfunction isProcedure(procedureOrRouter) {\n    return typeof procedureOrRouter === 'function';\n}\n/**\n * @internal\n */ async function getProcedureAtPath(router, path) {\n    const { _def } = router;\n    let procedure = _def.procedures[path];\n    while(!procedure){\n        const key = Object.keys(_def.lazy).find((key)=>path.startsWith(key));\n        // console.log(`found lazy: ${key ?? 'NOPE'} (fullPath: ${fullPath})`);\n        if (!key) {\n            return null;\n        }\n        // console.log('loading', key, '.......');\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lazyRouter = _def.lazy[key];\n        await lazyRouter.load();\n        procedure = _def.procedures[path];\n    }\n    return procedure;\n}\n/**\n * @internal\n */ async function callProcedure(opts) {\n    const { type, path } = opts;\n    const proc = await getProcedureAtPath(opts.router, path);\n    if (!proc || !isProcedure(proc) || proc._def.type !== type && !opts.allowMethodOverride) {\n        throw new TRPCError({\n            code: 'NOT_FOUND',\n            message: `No \"${type}\"-procedure on path \"${path}\"`\n        });\n    }\n    /* istanbul ignore if -- @preserve */ if (proc._def.type !== type && opts.allowMethodOverride && proc._def.type === 'subscription') {\n        throw new TRPCError({\n            code: 'METHOD_NOT_SUPPORTED',\n            message: `Method override is not supported for subscriptions`\n        });\n    }\n    return proc(opts);\n}\nfunction createCallerFactory() {\n    return function createCallerInner(router) {\n        const { _def } = router;\n        return function createCaller(ctxOrCallback, opts) {\n            return createRecursiveProxy(async ({ path, args })=>{\n                const fullPath = path.join('.');\n                if (path.length === 1 && path[0] === '_def') {\n                    return _def;\n                }\n                const procedure = await getProcedureAtPath(router, fullPath);\n                let ctx = undefined;\n                try {\n                    if (!procedure) {\n                        throw new TRPCError({\n                            code: 'NOT_FOUND',\n                            message: `No procedure found on path \"${path}\"`\n                        });\n                    }\n                    ctx = isFunction(ctxOrCallback) ? await Promise.resolve(ctxOrCallback()) : ctxOrCallback;\n                    return await procedure({\n                        path: fullPath,\n                        getRawInput: async ()=>args[0],\n                        ctx,\n                        type: procedure._def.type,\n                        signal: opts?.signal\n                    });\n                } catch (cause) {\n                    opts?.onError?.({\n                        ctx,\n                        error: getTRPCErrorFromUnknown(cause),\n                        input: args[0],\n                        path: fullPath,\n                        type: procedure?._def.type ?? 'unknown'\n                    });\n                    throw cause;\n                }\n            });\n        };\n    };\n}\nfunction mergeRouters(...routerList) {\n    const record = mergeWithoutOverrides({}, ...routerList.map((r)=>r._def.record));\n    const errorFormatter = routerList.reduce((currentErrorFormatter, nextRouter)=>{\n        if (nextRouter._def._config.errorFormatter && nextRouter._def._config.errorFormatter !== defaultFormatter) {\n            if (currentErrorFormatter !== defaultFormatter && currentErrorFormatter !== nextRouter._def._config.errorFormatter) {\n                throw new Error('You seem to have several error formatters');\n            }\n            return nextRouter._def._config.errorFormatter;\n        }\n        return currentErrorFormatter;\n    }, defaultFormatter);\n    const transformer = routerList.reduce((prev, current)=>{\n        if (current._def._config.transformer && current._def._config.transformer !== defaultTransformer) {\n            if (prev !== defaultTransformer && prev !== current._def._config.transformer) {\n                throw new Error('You seem to have several transformers');\n            }\n            return current._def._config.transformer;\n        }\n        return prev;\n    }, defaultTransformer);\n    const router = createRouterFactory({\n        errorFormatter,\n        transformer,\n        isDev: routerList.every((r)=>r._def._config.isDev),\n        allowOutsideOfServer: routerList.every((r)=>r._def._config.allowOutsideOfServer),\n        isServer: routerList.every((r)=>r._def._config.isServer),\n        $types: routerList[0]?._def._config.$types\n    })(record);\n    return router;\n}\n\nexport { callProcedure, createCallerFactory, createRouterFactory, getProcedureAtPath, lazy, mergeRouters };\n", "/* eslint-disable @typescript-eslint/unbound-method */ function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nvar _computedKey;\n/** Memory safe (weakmapped) cache of the ProxyPromise for each Promise,\n * which is retained for the lifetime of the original Promise.\n */ const subscribableCache = new WeakMap();\n/** A NOOP function allowing a consistent interface for settled\n * SubscribedPromises (settled promises are not subscribed - they resolve\n * immediately). */ const NOOP = ()=>{\n// noop\n};\n_computedKey = Symbol.toStringTag;\nlet _computedKey1 = _computedKey;\n/**\n * Every `Promise<T>` can be shadowed by a single `ProxyPromise<T>`. It is\n * created once, cached and reused throughout the lifetime of the Promise. Get a\n * Promise's ProxyPromise using `Unpromise.proxy(promise)`.\n *\n * The `ProxyPromise<T>` attaches handlers to the original `Promise<T>`\n * `.then()` and `.catch()` just once. Promises derived from it use a\n * subscription- (and unsubscription-) based mechanism that monitors these\n * handlers.\n *\n * Every time you call `.subscribe()`, `.then()` `.catch()` or `.finally()` on a\n * `ProxyPromise<T>` it returns a `SubscribedPromise<T>` having an additional\n * `unsubscribe()` method. Calling `unsubscribe()` detaches reference chains\n * from the original, potentially long-lived Promise, eliminating memory leaks.\n *\n * This approach can eliminate the memory leaks that otherwise come about from\n * repeated `race()` or `any()` calls invoking `.then()` and `.catch()` multiple\n * times on the same long-lived native Promise (subscriptions which can never be\n * cleaned up).\n *\n * `Unpromise.race(promises)` is a reference implementation of `Promise.race`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.any(promises)` is a reference implementation of `Promise.any`\n * avoiding memory leaks when using long-lived unsettled Promises.\n *\n * `Unpromise.resolve(promise)` returns an ephemeral `SubscribedPromise<T>` for\n * any given `Promise<T>` facilitating arbitrary async/await patterns. Behind\n * the scenes, `resolve` is implemented simply as\n * `Unpromise.proxy(promise).subscribe()`. Don't forget to call `.unsubscribe()`\n * to tidy up!\n *\n */ class Unpromise {\n    /** Create a promise that mitigates uncontrolled subscription to a long-lived\n   * Promise via .then() and .catch() - otherwise a source of memory leaks.\n   *\n   * The returned promise has an `unsubscribe()` method which can be called when\n   * the Promise is no longer being tracked by application logic, and which\n   * ensures that there is no reference chain from the original promise to the\n   * new one, and therefore no memory leak.\n   *\n   * If original promise has not yet settled, this adds a new unique promise\n   * that listens to then/catch events, along with an `unsubscribe()` method to\n   * detach it.\n   *\n   * If original promise has settled, then creates a new Promise.resolve() or\n   * Promise.reject() and provided unsubscribe is a noop.\n   *\n   * If you call `unsubscribe()` before the returned Promise has settled, it\n   * will never settle.\n   */ subscribe() {\n        // in all cases we will combine some promise with its unsubscribe function\n        let promise;\n        let unsubscribe;\n        const { settlement } = this;\n        if (settlement === null) {\n            // not yet settled - subscribe new promise. Expect eventual settlement\n            if (this.subscribers === null) {\n                // invariant - it is not settled, so it must have subscribers\n                throw new Error(\"Unpromise settled but still has subscribers\");\n            }\n            const subscriber = withResolvers();\n            this.subscribers = listWithMember(this.subscribers, subscriber);\n            promise = subscriber.promise;\n            unsubscribe = ()=>{\n                if (this.subscribers !== null) {\n                    this.subscribers = listWithoutMember(this.subscribers, subscriber);\n                }\n            };\n        } else {\n            // settled - don't create subscribed promise. Just resolve or reject\n            const { status } = settlement;\n            if (status === \"fulfilled\") {\n                promise = Promise.resolve(settlement.value);\n            } else {\n                promise = Promise.reject(settlement.reason);\n            }\n            unsubscribe = NOOP;\n        }\n        // extend promise signature with the extra method\n        return Object.assign(promise, {\n            unsubscribe\n        });\n    }\n    /** STANDARD PROMISE METHODS (but returning a SubscribedPromise) */ then(onfulfilled, onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.then(onfulfilled, onrejected), {\n            unsubscribe\n        });\n    }\n    catch(onrejected) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.catch(onrejected), {\n            unsubscribe\n        });\n    }\n    finally(onfinally) {\n        const subscribed = this.subscribe();\n        const { unsubscribe } = subscribed;\n        return Object.assign(subscribed.finally(onfinally), {\n            unsubscribe\n        });\n    }\n    /** Unpromise STATIC METHODS */ /** Create or Retrieve the proxy Unpromise (a re-used Unpromise for the VM lifetime\n   * of the provided Promise reference) */ static proxy(promise) {\n        const cached = Unpromise.getSubscribablePromise(promise);\n        return typeof cached !== \"undefined\" ? cached : Unpromise.createSubscribablePromise(promise);\n    }\n    /** Create and store an Unpromise keyed by an original Promise. */ static createSubscribablePromise(promise) {\n        const created = new Unpromise(promise);\n        subscribableCache.set(promise, created); // resolve promise to unpromise\n        subscribableCache.set(created, created); // resolve the unpromise to itself\n        return created;\n    }\n    /** Retrieve a previously-created Unpromise keyed by an original Promise. */ static getSubscribablePromise(promise) {\n        return subscribableCache.get(promise);\n    }\n    /** Promise STATIC METHODS */ /** Lookup the Unpromise for this promise, and derive a SubscribedPromise from\n   * it (that can be later unsubscribed to eliminate Memory leaks) */ static resolve(value) {\n        const promise = typeof value === \"object\" && value !== null && \"then\" in value && typeof value.then === \"function\" ? value : Promise.resolve(value);\n        return Unpromise.proxy(promise).subscribe();\n    }\n    static async any(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.any(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    static async race(values) {\n        const valuesArray = Array.isArray(values) ? values : [\n            ...values\n        ];\n        const subscribedPromises = valuesArray.map(Unpromise.resolve);\n        try {\n            return await Promise.race(subscribedPromises);\n        } finally{\n            subscribedPromises.forEach(({ unsubscribe })=>{\n                unsubscribe();\n            });\n        }\n    }\n    /** Create a race of SubscribedPromises that will fulfil to a single winning\n   * Promise (in a 1-Tuple). Eliminates memory leaks from long-lived promises\n   * accumulating .then() and .catch() subscribers. Allows simple logic to\n   * consume the result, like...\n   * ```ts\n   * const [ winner ] = await Unpromise.race([ promiseA, promiseB ]);\n   * if(winner === promiseB){\n   *   const result = await promiseB;\n   *   // do the thing\n   * }\n   * ```\n   * */ static async raceReferences(promises) {\n        // map each promise to an eventual 1-tuple containing itself\n        const selfPromises = promises.map(resolveSelfTuple);\n        // now race them. They will fulfil to a readonly [P] or reject.\n        try {\n            return await Promise.race(selfPromises);\n        } finally{\n            for (const promise of selfPromises){\n                // unsubscribe proxy promises when the race is over to mitigate memory leaks\n                promise.unsubscribe();\n            }\n        }\n    }\n    constructor(arg){\n        /** INSTANCE IMPLEMENTATION */ /** The promise shadowed by this Unpromise<T>  */ _define_property(this, \"promise\", void 0);\n        /** Promises expecting eventual settlement (unless unsubscribed first). This list is deleted\n   * after the original promise settles - no further notifications will be issued. */ _define_property(this, \"subscribers\", []);\n        /** The Promise's settlement (recorded when it fulfils or rejects). This is consulted when\n   * calling .subscribe() .then() .catch() .finally() to see if an immediately-resolving Promise\n   * can be returned, and therefore subscription can be bypassed. */ _define_property(this, \"settlement\", null);\n        /** TOSTRING SUPPORT */ _define_property(this, _computedKey1, \"Unpromise\");\n        // handle either a Promise or a Promise executor function\n        if (typeof arg === \"function\") {\n            this.promise = new Promise(arg);\n        } else {\n            this.promise = arg;\n        }\n        // subscribe for eventual fulfilment and rejection\n        // handle PromiseLike objects (that at least have .then)\n        const thenReturn = this.promise.then((value)=>{\n            // atomically record fulfilment and detach subscriber list\n            const { subscribers } = this;\n            this.subscribers = null;\n            this.settlement = {\n                status: \"fulfilled\",\n                value\n            };\n            // notify fulfilment to subscriber list\n            subscribers?.forEach(({ resolve })=>{\n                resolve(value);\n            });\n        });\n        // handle Promise (that also have a .catch behaviour)\n        if (\"catch\" in thenReturn) {\n            thenReturn.catch((reason)=>{\n                // atomically record rejection and detach subscriber list\n                const { subscribers } = this;\n                this.subscribers = null;\n                this.settlement = {\n                    status: \"rejected\",\n                    reason\n                };\n                // notify rejection to subscriber list\n                subscribers?.forEach(({ reject })=>{\n                    reject(reason);\n                });\n            });\n        }\n    }\n}\n/** Promises a 1-tuple containing the original promise when it resolves. Allows\n * awaiting the eventual Promise ***reference*** (easy to destructure and\n * exactly compare with ===). Avoids resolving to the Promise ***value*** (which\n * may be ambiguous and therefore hard to identify as the winner of a race).\n * You can call unsubscribe on the Promise to mitigate memory leaks.\n * */ function resolveSelfTuple(promise) {\n    return Unpromise.proxy(promise).then(()=>[\n            promise\n        ]);\n}\n/** VENDORED (Future) PROMISE UTILITIES */ /** Reference implementation of https://github.com/tc39/proposal-promise-with-resolvers */ function withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject)=>{\n        resolve = _resolve;\n        reject = _reject;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n/** IMMUTABLE LIST OPERATIONS */ function listWithMember(arr, member) {\n    return [\n        ...arr,\n        member\n    ];\n}\nfunction listWithoutIndex(arr, index) {\n    return [\n        ...arr.slice(0, index),\n        ...arr.slice(index + 1)\n    ];\n}\nfunction listWithoutMember(arr, member) {\n    const index = arr.indexOf(member);\n    if (index !== -1) {\n        return listWithoutIndex(arr, index);\n    }\n    return arr;\n}\n\nexport { Unpromise, resolveSelfTuple };\n", "// @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\nvar _Symbol, // @ts-expect-error - polyfilling symbol\n// eslint-disable-next-line no-restricted-syntax\n_Symbol1;\n(_Symbol = Symbol).dispose ?? (_Symbol.dispose = Symbol());\n(_Symbol1 = Symbol).asyncDispose ?? (_Symbol1.asyncDispose = Symbol());\n/**\n * Takes a value and a dispose function and returns a new object that implements the Disposable interface.\n * The returned object is the original value augmented with a Symbol.dispose method.\n * @param thing The value to make disposable\n * @param dispose Function to call when disposing the resource\n * @returns The original value with Symbol.dispose method added\n */ function makeResource(thing, dispose) {\n    const it = thing;\n    // eslint-disable-next-line no-restricted-syntax\n    const existing = it[Symbol.dispose];\n    // eslint-disable-next-line no-restricted-syntax\n    it[Symbol.dispose] = ()=>{\n        dispose();\n        existing?.();\n    };\n    return it;\n}\n/**\n * Takes a value and an async dispose function and returns a new object that implements the AsyncDisposable interface.\n * The returned object is the original value augmented with a Symbol.asyncDispose method.\n * @param thing The value to make async disposable\n * @param dispose Async function to call when disposing the resource\n * @returns The original value with Symbol.asyncDispose method added\n */ function makeAsyncResource(thing, dispose) {\n    const it = thing;\n    // eslint-disable-next-line no-restricted-syntax\n    const existing = it[Symbol.asyncDispose];\n    // eslint-disable-next-line no-restricted-syntax\n    it[Symbol.asyncDispose] = async ()=>{\n        await dispose();\n        await existing?.();\n    };\n    return it;\n}\n\nexport { makeAsyncResource, makeResource };\n", "import { makeResource } from './disposable.mjs';\n\nconst disposablePromiseTimerResult = Symbol();\nfunction timerResource(ms) {\n    let timer = null;\n    return makeResource({\n        start () {\n            if (timer) {\n                throw new Error('Timer already started');\n            }\n            const promise = new Promise((resolve)=>{\n                timer = setTimeout(()=>resolve(disposablePromiseTimerResult), ms);\n            });\n            return promise;\n        }\n    }, ()=>{\n        if (timer) {\n            clearTimeout(timer);\n        }\n    });\n}\n\nexport { disposablePromiseTimerResult, timerResource };\n", "import { Unpromise } from '../../../vendor/unpromise/unpromise.mjs';\nimport { iteratorResource } from './asyncIterable.mjs';\nimport { timerResource, disposablePromiseTimerResult } from './timerResource.mjs';\n\nfunction _ts_add_disposable_resource(env, value, async) {\n    if (value !== null && value !== void 0) {\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n        var dispose, inner;\n        if (async) {\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n            dispose = value[Symbol.asyncDispose];\n        }\n        if (dispose === void 0) {\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n            dispose = value[Symbol.dispose];\n            if (async) inner = dispose;\n        }\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n        if (inner) dispose = function() {\n            try {\n                inner.call(this);\n            } catch (e) {\n                return Promise.reject(e);\n            }\n        };\n        env.stack.push({\n            value: value,\n            dispose: dispose,\n            async: async\n        });\n    } else if (async) {\n        env.stack.push({\n            async: true\n        });\n    }\n    return value;\n}\nfunction _ts_dispose_resources(env) {\n    var _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n        var e = new Error(message);\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n    };\n    return (_ts_dispose_resources = function _ts_dispose_resources(env) {\n        function fail(e) {\n            env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n            env.hasError = true;\n        }\n        var r, s = 0;\n        function next() {\n            while(r = env.stack.pop()){\n                try {\n                    if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n                    if (r.dispose) {\n                        var result = r.dispose.call(r.value);\n                        if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {\n                            fail(e);\n                            return next();\n                        });\n                    } else s |= 1;\n                } catch (e) {\n                    fail(e);\n                }\n            }\n            if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n            if (env.hasError) throw env.error;\n        }\n        return next();\n    })(env);\n}\nconst PING_SYM = Symbol('ping');\n/**\n * Derives a new {@link AsyncGenerator} based of {@link iterable}, that yields {@link PING_SYM}\n * whenever no value has been yielded for {@link pingIntervalMs}.\n */ async function* withPing(iterable, pingIntervalMs) {\n    const env = {\n        stack: [],\n        error: void 0,\n        hasError: false\n    };\n    try {\n        const iterator = _ts_add_disposable_resource(env, iteratorResource(iterable), true);\n        ;\n        // declaration outside the loop for garbage collection reasons\n        let result;\n        let nextPromise = iterator.next();\n        while(true){\n            const env = {\n                stack: [],\n                error: void 0,\n                hasError: false\n            };\n            try {\n                const pingPromise = _ts_add_disposable_resource(env, timerResource(pingIntervalMs), false);\n                ;\n                result = await Unpromise.race([\n                    nextPromise,\n                    pingPromise.start()\n                ]);\n                if (result === disposablePromiseTimerResult) {\n                    // cancelled\n                    yield PING_SYM;\n                    continue;\n                }\n                if (result.done) {\n                    return result.value;\n                }\n                nextPromise = iterator.next();\n                yield result.value;\n                // free up reference for garbage collection\n                result = null;\n            } catch (e) {\n                env.error = e;\n                env.hasError = true;\n            } finally{\n                _ts_dispose_resources(env);\n            }\n        }\n    } catch (e) {\n        env.error = e;\n        env.hasError = true;\n    } finally{\n        const result = _ts_dispose_resources(env);\n        if (result) await result;\n    }\n}\n\nexport { PING_SYM, withPing };\n", "const trackedSymbol = Symbol();\n/**\n * Produce a typed server-sent event message\n * @deprecated use `tracked(id, data)` instead\n */ function sse(event) {\n    return tracked(event.id, event.data);\n}\nfunction isTrackedEnvelope(value) {\n    return Array.isArray(value) && value[2] === trackedSymbol;\n}\n/**\n * Automatically track an event so that it can be resumed from a given id if the connection is lost\n */ function tracked(id, data) {\n    if (id === '') {\n        // This limitation could be removed by using different SSE event names / channels for tracked event and non-tracked event\n        throw new Error('`id` must not be an empty string as empty string is the same as not setting the id at all');\n    }\n    return [\n        id,\n        data,\n        trackedSymbol\n    ];\n}\n\nexport { isTrackedEnvelope, sse, tracked };\n", "import { TRPCError } from './error/TRPCError.mjs';\nimport { isObject } from './utils.mjs';\n\n/** @internal */ const middlewareMarker = 'middlewareMarker';\n/**\n * @internal\n */ function createMiddlewareFactory() {\n    function createMiddlewareInner(middlewares) {\n        return {\n            _middlewares: middlewares,\n            unstable_pipe (middlewareBuilderOrFn) {\n                const pipedMiddleware = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                    middlewareBuilderOrFn\n                ];\n                return createMiddlewareInner([\n                    ...middlewares,\n                    ...pipedMiddleware\n                ]);\n            }\n        };\n    }\n    function createMiddleware(fn) {\n        return createMiddlewareInner([\n            fn\n        ]);\n    }\n    return createMiddleware;\n}\n/**\n * Create a standalone middleware\n * @see https://trpc.io/docs/v11/server/middlewares#experimental-standalone-middlewares\n * @deprecated use `.concat()` instead\n */ const experimental_standaloneMiddleware = ()=>({\n        create: createMiddlewareFactory()\n    });\n/**\n * @internal\n * Please note, `trpc-openapi` uses this function.\n */ function createInputMiddleware(parse) {\n    const inputMiddleware = async function inputValidatorMiddleware(opts) {\n        let parsedInput;\n        const rawInput = await opts.getRawInput();\n        try {\n            parsedInput = await parse(rawInput);\n        } catch (cause) {\n            throw new TRPCError({\n                code: 'BAD_REQUEST',\n                cause\n            });\n        }\n        // Multiple input parsers\n        const combinedInput = isObject(opts.input) && isObject(parsedInput) ? {\n            ...opts.input,\n            ...parsedInput\n        } : parsedInput;\n        return opts.next({\n            input: combinedInput\n        });\n    };\n    inputMiddleware._type = 'input';\n    return inputMiddleware;\n}\n/**\n * @internal\n */ function createOutputMiddleware(parse) {\n    const outputMiddleware = async function outputValidatorMiddleware({ next }) {\n        const result = await next();\n        if (!result.ok) {\n            // pass through failures without validating\n            return result;\n        }\n        try {\n            const data = await parse(result.data);\n            return {\n                ...result,\n                data\n            };\n        } catch (cause) {\n            throw new TRPCError({\n                message: 'Output validation failed',\n                code: 'INTERNAL_SERVER_ERROR',\n                cause\n            });\n        }\n    };\n    outputMiddleware._type = 'output';\n    return outputMiddleware;\n}\n\nexport { createInputMiddleware, createMiddlewareFactory, createOutputMiddleware, experimental_standaloneMiddleware, middlewareMarker };\n", "function _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/** A schema error with useful information. */ class StandardSchemaV1Error extends Error {\n    /**\n   * Creates a schema error with useful information.\n   *\n   * @param issues The schema issues.\n   */ constructor(issues){\n        super(issues[0]?.message), /** The schema issues. */ _define_property(this, \"issues\", void 0);\n        this.name = 'SchemaError';\n        this.issues = issues;\n    }\n}\n\nexport { StandardSchemaV1Error };\n", "import { StandardSchemaV1Error } from '../vendor/standard-schema-v1/error.mjs';\n\nfunction getParseFn(procedureParser) {\n    const parser = procedureParser;\n    if (typeof parser === 'function' && typeof parser.assert === 'function') {\n        // ParserArkTypeEsque - arktype schemas shouldn't be called as a function because they return a union type instead of throwing\n        return parser.assert.bind(parser);\n    }\n    if (typeof parser === 'function') {\n        // ParserValibotEsque (>= v0.31.0)\n        // ParserCustomValidatorEsque\n        return parser;\n    }\n    if (typeof parser.parseAsync === 'function') {\n        // ParserZodEsque\n        return parser.parseAsync.bind(parser);\n    }\n    if (typeof parser.parse === 'function') {\n        // ParserZodEsque\n        // ParserValibotEsque (< v0.13.0)\n        return parser.parse.bind(parser);\n    }\n    if (typeof parser.validateSync === 'function') {\n        // ParserYupEsque\n        return parser.validateSync.bind(parser);\n    }\n    if (typeof parser.create === 'function') {\n        // ParserSuperstructEsque\n        return parser.create.bind(parser);\n    }\n    if (typeof parser.assert === 'function') {\n        // ParserScaleEsque\n        return (value)=>{\n            parser.assert(value);\n            return value;\n        };\n    }\n    if ('~standard' in parser) {\n        // StandardSchemaEsque\n        return async (value)=>{\n            const result = await parser['~standard'].validate(value);\n            if (result.issues) {\n                throw new StandardSchemaV1Error(result.issues);\n            }\n            return result.value;\n        };\n    }\n    throw new Error('Could not find a validator fn');\n}\n\nexport { getParseFn };\n", "import { TRPCError, getTRPCErrorFromUnknown } from './error/TRPCError.mjs';\nimport { createOutputMiddleware, createInputMiddleware, middlewareMarker } from './middleware.mjs';\nimport { getParseFn } from './parser.mjs';\nimport { mergeWithoutOverrides } from './utils.mjs';\n\nfunction createNewBuilder(def1, def2) {\n    const { middlewares = [], inputs, meta, ...rest } = def2;\n    // TODO: maybe have a fn here to warn about calls\n    return createBuilder({\n        ...mergeWithoutOverrides(def1, rest),\n        inputs: [\n            ...def1.inputs,\n            ...inputs ?? []\n        ],\n        middlewares: [\n            ...def1.middlewares,\n            ...middlewares\n        ],\n        meta: def1.meta && meta ? {\n            ...def1.meta,\n            ...meta\n        } : meta ?? def1.meta\n    });\n}\nfunction createBuilder(initDef = {}) {\n    const _def = {\n        procedure: true,\n        inputs: [],\n        middlewares: [],\n        ...initDef\n    };\n    const builder = {\n        _def,\n        input (input) {\n            const parser = getParseFn(input);\n            return createNewBuilder(_def, {\n                inputs: [\n                    input\n                ],\n                middlewares: [\n                    createInputMiddleware(parser)\n                ]\n            });\n        },\n        output (output) {\n            const parser = getParseFn(output);\n            return createNewBuilder(_def, {\n                output,\n                middlewares: [\n                    createOutputMiddleware(parser)\n                ]\n            });\n        },\n        meta (meta) {\n            return createNewBuilder(_def, {\n                meta\n            });\n        },\n        use (middlewareBuilderOrFn) {\n            // Distinguish between a middleware builder and a middleware function\n            const middlewares = '_middlewares' in middlewareBuilderOrFn ? middlewareBuilderOrFn._middlewares : [\n                middlewareBuilderOrFn\n            ];\n            return createNewBuilder(_def, {\n                middlewares: middlewares\n            });\n        },\n        unstable_concat (builder) {\n            return createNewBuilder(_def, builder._def);\n        },\n        concat (builder) {\n            return createNewBuilder(_def, builder._def);\n        },\n        query (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'query'\n            }, resolver);\n        },\n        mutation (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'mutation'\n            }, resolver);\n        },\n        subscription (resolver) {\n            return createResolver({\n                ..._def,\n                type: 'subscription'\n            }, resolver);\n        },\n        experimental_caller (caller) {\n            return createNewBuilder(_def, {\n                caller\n            });\n        }\n    };\n    return builder;\n}\nfunction createResolver(_defIn, resolver) {\n    const finalBuilder = createNewBuilder(_defIn, {\n        resolver,\n        middlewares: [\n            async function resolveMiddleware(opts) {\n                const data = await resolver(opts);\n                return {\n                    marker: middlewareMarker,\n                    ok: true,\n                    data,\n                    ctx: opts.ctx\n                };\n            }\n        ]\n    });\n    const _def = {\n        ...finalBuilder._def,\n        type: _defIn.type,\n        experimental_caller: Boolean(finalBuilder._def.caller),\n        meta: finalBuilder._def.meta,\n        $types: null\n    };\n    const invoke = createProcedureCaller(finalBuilder._def);\n    const callerOverride = finalBuilder._def.caller;\n    if (!callerOverride) {\n        return invoke;\n    }\n    const callerWrapper = async (...args)=>{\n        return await callerOverride({\n            args,\n            invoke,\n            _def: _def\n        });\n    };\n    callerWrapper._def = _def;\n    return callerWrapper;\n}\nconst codeblock = `\nThis is a client-only function.\nIf you want to call this function on the server, see https://trpc.io/docs/v11/server/server-side-calls\n`.trim();\n// run the middlewares recursively with the resolver as the last one\nasync function callRecursive(index, _def, opts) {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const middleware = _def.middlewares[index];\n        const result = await middleware({\n            ...opts,\n            meta: _def.meta,\n            input: opts.input,\n            next (_nextOpts) {\n                const nextOpts = _nextOpts;\n                return callRecursive(index + 1, _def, {\n                    ...opts,\n                    ctx: nextOpts?.ctx ? {\n                        ...opts.ctx,\n                        ...nextOpts.ctx\n                    } : opts.ctx,\n                    input: nextOpts && 'input' in nextOpts ? nextOpts.input : opts.input,\n                    getRawInput: nextOpts?.getRawInput ?? opts.getRawInput\n                });\n            }\n        });\n        return result;\n    } catch (cause) {\n        return {\n            ok: false,\n            error: getTRPCErrorFromUnknown(cause),\n            marker: middlewareMarker\n        };\n    }\n}\nfunction createProcedureCaller(_def) {\n    async function procedure(opts) {\n        // is direct server-side call\n        if (!opts || !('getRawInput' in opts)) {\n            throw new Error(codeblock);\n        }\n        // there's always at least one \"next\" since we wrap this.resolver in a middleware\n        const result = await callRecursive(0, _def, opts);\n        if (!result) {\n            throw new TRPCError({\n                code: 'INTERNAL_SERVER_ERROR',\n                message: 'No result from middlewares - did you forget to `return next()`?'\n            });\n        }\n        if (!result.ok) {\n            // re-throw original error\n            throw result.error;\n        }\n        return result.data;\n    }\n    procedure._def = _def;\n    procedure.procedure = true;\n    // FIXME typecast shouldn't be needed - fixittt\n    return procedure;\n}\n\nexport { createBuilder };\n", "/**\n * The default check to see if we're in a server\n */ const isServerDefault = typeof window === 'undefined' || 'Deno' in window || // eslint-disable-next-line @typescript-eslint/dot-notation\nglobalThis.process?.env?.['NODE_ENV'] === 'test' || !!globalThis.process?.env?.['JEST_WORKER_ID'] || !!globalThis.process?.env?.['VITEST_WORKER_ID'];\n\nexport { isServerDefault };\n", "import { defaultFormatter } from './error/formatter.mjs';\nimport { createMiddlewareFactory } from './middleware.mjs';\nimport { createBuilder } from './procedureBuilder.mjs';\nimport { isServerDefault } from './rootConfig.mjs';\nimport { createCallerFactory, mergeRouters, createRouterFactory } from './router.mjs';\nimport { getDataTransformer, defaultTransformer } from './transformer.mjs';\n\nclass TRPCBuilder {\n    /**\n   * Add a context shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/server/context\n   */ context() {\n        return new TRPCBuilder();\n    }\n    /**\n   * Add a meta shape as a generic to the root object\n   * @see https://trpc.io/docs/v11/quickstart\n   */ meta() {\n        return new TRPCBuilder();\n    }\n    /**\n   * Create the root object\n   * @see https://trpc.io/docs/v11/server/routers#initialize-trpc\n   */ create(opts) {\n        const config = {\n            ...opts,\n            transformer: getDataTransformer(opts?.transformer ?? defaultTransformer),\n            isDev: opts?.isDev ?? // eslint-disable-next-line @typescript-eslint/dot-notation\n            globalThis.process?.env['NODE_ENV'] !== 'production',\n            allowOutsideOfServer: opts?.allowOutsideOfServer ?? false,\n            errorFormatter: opts?.errorFormatter ?? defaultFormatter,\n            isServer: opts?.isServer ?? isServerDefault,\n            /**\n       * These are just types, they can't be used at runtime\n       * @internal\n       */ $types: null\n        };\n        {\n            // Server check\n            const isServer = opts?.isServer ?? isServerDefault;\n            if (!isServer && opts?.allowOutsideOfServer !== true) {\n                throw new Error(`You're trying to use @trpc/server in a non-server environment. This is not supported by default.`);\n            }\n        }\n        return {\n            /**\n       * Your router config\n       * @internal\n       */ _config: config,\n            /**\n       * Builder object for creating procedures\n       * @see https://trpc.io/docs/v11/server/procedures\n       */ procedure: createBuilder({\n                meta: opts?.defaultMeta\n            }),\n            /**\n       * Create reusable middlewares\n       * @see https://trpc.io/docs/v11/server/middlewares\n       */ middleware: createMiddlewareFactory(),\n            /**\n       * Create a router\n       * @see https://trpc.io/docs/v11/server/routers\n       */ router: createRouterFactory(config),\n            /**\n       * Merge Routers\n       * @see https://trpc.io/docs/v11/server/merging-routers\n       */ mergeRouters,\n            /**\n       * Create a server-side caller for a router\n       * @see https://trpc.io/docs/v11/server/server-side-calls\n       */ createCallerFactory: createCallerFactory()\n        };\n    }\n}\n/**\n * Builder to initialize the tRPC root object - use this exactly once per backend\n * @see https://trpc.io/docs/v11/quickstart\n */ const initTRPC = new TRPCBuilder();\n\nexport { initTRPC };\n", "import { isObject } from '@trpc/server/unstable-core-do-not-import';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction isTRPCClientError(cause) {\n    return cause instanceof TRPCClientError || /**\n     * @deprecated\n     * Delete in next major\n     */ cause instanceof Error && cause.name === 'TRPCClientError';\n}\nfunction isTRPCErrorResponse(obj) {\n    return isObject(obj) && isObject(obj['error']) && typeof obj['error']['code'] === 'number' && typeof obj['error']['message'] === 'string';\n}\nfunction getMessageFromUnknownError(err, fallback) {\n    if (typeof err === 'string') {\n        return err;\n    }\n    if (isObject(err) && typeof err['message'] === 'string') {\n        return err['message'];\n    }\n    return fallback;\n}\nclass TRPCClientError extends Error {\n    static from(_cause, opts = {}) {\n        const cause = _cause;\n        if (isTRPCClientError(cause)) {\n            if (opts.meta) {\n                // Decorate with meta error data\n                cause.meta = {\n                    ...cause.meta,\n                    ...opts.meta\n                };\n            }\n            return cause;\n        }\n        if (isTRPCErrorResponse(cause)) {\n            return new TRPCClientError(cause.error.message, {\n                ...opts,\n                result: cause\n            });\n        }\n        return new TRPCClientError(getMessageFromUnknownError(cause, 'Unknown error'), {\n            ...opts,\n            cause: cause\n        });\n    }\n    constructor(message, opts){\n        const cause = opts?.cause;\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore https://github.com/tc39/proposal-error-cause\n        super(message, {\n            cause\n        }), // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore override doesn't work in all environments due to \"This member cannot have an 'override' modifier because it is not declared in the base class 'Error'\"\n        _define_property(this, \"cause\", void 0), _define_property(this, \"shape\", void 0), _define_property(this, \"data\", void 0), /**\n   * Additional meta data about the error\n   * In the case of HTTP-errors, we'll have `response` and potentially `responseJSON` here\n   */ _define_property(this, \"meta\", void 0);\n        this.meta = opts?.meta;\n        this.cause = cause;\n        this.shape = opts?.result?.error;\n        this.data = opts?.result?.error.data;\n        this.name = 'TRPCClientError';\n        Object.setPrototypeOf(this, TRPCClientError.prototype);\n    }\n}\n\nexport { TRPCClientError };\n", "import { share, observableToPromise } from '@trpc/server/observable';\nimport { createChain } from '../links/internals/createChain.mjs';\nimport { TRPCClientError } from '../TRPCClientError.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass TRPCUntypedClient {\n    $request(opts) {\n        const chain$ = createChain({\n            links: this.links,\n            op: {\n                ...opts,\n                context: opts.context ?? {},\n                id: ++this.requestId\n            }\n        });\n        return chain$.pipe(share());\n    }\n    async requestAsPromise(opts) {\n        try {\n            const req$ = this.$request(opts);\n            const envelope = await observableToPromise(req$);\n            const data = envelope.result.data;\n            return data;\n        } catch (err) {\n            throw TRPCClientError.from(err);\n        }\n    }\n    query(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'query',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    mutation(path, input, opts) {\n        return this.requestAsPromise({\n            type: 'mutation',\n            path,\n            input,\n            context: opts?.context,\n            signal: opts?.signal\n        });\n    }\n    subscription(path, input, opts) {\n        const observable$ = this.$request({\n            type: 'subscription',\n            path,\n            input,\n            context: opts.context,\n            signal: opts.signal\n        });\n        return observable$.subscribe({\n            next (envelope) {\n                switch(envelope.result.type){\n                    case 'state':\n                        {\n                            opts.onConnectionStateChange?.(envelope.result);\n                            break;\n                        }\n                    case 'started':\n                        {\n                            opts.onStarted?.({\n                                context: envelope.context\n                            });\n                            break;\n                        }\n                    case 'stopped':\n                        {\n                            opts.onStopped?.();\n                            break;\n                        }\n                    case 'data':\n                    case undefined:\n                        {\n                            opts.onData?.(envelope.result.data);\n                            break;\n                        }\n                }\n            },\n            error (err) {\n                opts.onError?.(err);\n            },\n            complete () {\n                opts.onComplete?.();\n            }\n        });\n    }\n    constructor(opts){\n        _define_property(this, \"links\", void 0);\n        _define_property(this, \"runtime\", void 0);\n        _define_property(this, \"requestId\", void 0);\n        this.requestId = 0;\n        this.runtime = {};\n        // Initialize the links\n        this.links = opts.links.map((link)=>link(this.runtime));\n    }\n}\n\nexport { TRPCUntypedClient };\n", "import { createRecursiveProxy, createFlatProxy } from '@trpc/server/unstable-core-do-not-import';\nimport { TRPCUntypedClient } from './internals/TRPCUntypedClient.mjs';\n\nconst untypedClientSymbol = Symbol.for('trpc_untypedClient');\nconst clientCallTypeMap = {\n    query: 'query',\n    mutate: 'mutation',\n    subscribe: 'subscription'\n};\n/** @internal */ const clientCallTypeToProcedureType = (clientCallType)=>{\n    return clientCallTypeMap[clientCallType];\n};\n/**\n * @internal\n */ function createTRPCClientProxy(client) {\n    const proxy = createRecursiveProxy(({ path, args })=>{\n        const pathCopy = [\n            ...path\n        ];\n        const procedureType = clientCallTypeToProcedureType(pathCopy.pop());\n        const fullPath = pathCopy.join('.');\n        return client[procedureType](fullPath, ...args);\n    });\n    return createFlatProxy((key)=>{\n        if (key === untypedClientSymbol) {\n            return client;\n        }\n        return proxy[key];\n    });\n}\nfunction createTRPCClient(opts) {\n    const client = new TRPCUntypedClient(opts);\n    const proxy = createTRPCClientProxy(client);\n    return proxy;\n}\n/**\n * Get an untyped client from a proxy client\n * @internal\n */ function getUntypedClient(client) {\n    return client[untypedClientSymbol];\n}\n\nexport { clientCallTypeToProcedureType, createTRPCClient, createTRPCClientProxy, getUntypedClient };\n", "/**\n * Get the result of a value or function that returns a value\n * It also optionally accepts typesafe arguments for the function\n */ const resultOf = (value, ...args)=>{\n    return typeof value === 'function' ? value(...args) : value;\n};\n\nexport { resultOf };\n", "import { resultOf } from '../../internals/urlWithConnectionParams.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nclass TRPCWebSocketClosedError extends Error {\n    constructor(opts){\n        super(opts.message, {\n            cause: opts.cause\n        });\n        this.name = 'TRPCWebSocketClosedError';\n        Object.setPrototypeOf(this, TRPCWebSocketClosedError.prototype);\n    }\n}\n/**\n * Utility class for managing a timeout that can be started, stopped, and reset.\n * Useful for scenarios where the timeout duration is reset dynamically based on events.\n */ class ResettableTimeout {\n    /**\n   * Resets the current timeout, restarting it with the same duration.\n   * Does nothing if no timeout is active.\n   */ reset() {\n        if (!this.timeout) return;\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n    }\n    start() {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(this.onTimeout, this.timeoutMs);\n    }\n    stop() {\n        clearTimeout(this.timeout);\n        this.timeout = undefined;\n    }\n    constructor(onTimeout, timeoutMs){\n        _define_property(this, \"onTimeout\", void 0);\n        _define_property(this, \"timeoutMs\", void 0);\n        _define_property(this, \"timeout\", void 0);\n        this.onTimeout = onTimeout;\n        this.timeoutMs = timeoutMs;\n    }\n}\n// Ponyfill for Promise.withResolvers https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/withResolvers\nfunction withResolvers() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return {\n        promise,\n        resolve: resolve,\n        reject: reject\n    };\n}\n/**\n * Resolves a WebSocket URL and optionally appends connection parameters.\n *\n * If connectionParams are provided, appends 'connectionParams=1' query parameter.\n */ async function prepareUrl(urlOptions) {\n    const url = await resultOf(urlOptions.url);\n    if (!urlOptions.connectionParams) return url;\n    // append `?connectionParams=1` when connection params are used\n    const prefix = url.includes('?') ? '&' : '?';\n    const connectionParams = `${prefix}connectionParams=1`;\n    return url + connectionParams;\n}\nasync function buildConnectionMessage(connectionParams) {\n    const message = {\n        method: 'connectionParams',\n        data: await resultOf(connectionParams)\n    };\n    return JSON.stringify(message);\n}\n\nexport { ResettableTimeout, TRPCWebSocketClosedError, buildConnectionMessage, prepareUrl, withResolvers };\n", "import { behaviorSubject } from '@trpc/server/observable';\nimport { prepareUrl, buildConnectionMessage, withResolvers } from './utils.mjs';\n\nfunction _define_property(obj, key, value) {\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\n/**\n * Opens a WebSocket connection asynchronously and returns a promise\n * that resolves when the connection is successfully established.\n * The promise rejects if an error occurs during the connection attempt.\n */ function asyncWsOpen(ws) {\n    const { promise, resolve, reject } = withResolvers();\n    ws.addEventListener('open', ()=>{\n        ws.removeEventListener('error', reject);\n        resolve();\n    });\n    ws.addEventListener('error', reject);\n    return promise;\n}\n/**\n * Sets up a periodic ping-pong mechanism to keep the WebSocket connection alive.\n *\n * - Sends \"PING\" messages at regular intervals defined by `intervalMs`.\n * - If a \"PONG\" response is not received within the `pongTimeoutMs`, the WebSocket is closed.\n * - The ping timer resets upon receiving any message to maintain activity.\n * - Automatically starts the ping process when the WebSocket connection is opened.\n * - Cleans up timers when the WebSocket is closed.\n *\n * @param ws - The WebSocket instance to manage.\n * @param options - Configuration options for ping-pong intervals and timeouts.\n */ function setupPingInterval(ws, { intervalMs, pongTimeoutMs }) {\n    let pingTimeout;\n    let pongTimeout;\n    function start() {\n        pingTimeout = setTimeout(()=>{\n            ws.send('PING');\n            pongTimeout = setTimeout(()=>{\n                ws.close();\n            }, pongTimeoutMs);\n        }, intervalMs);\n    }\n    function reset() {\n        clearTimeout(pingTimeout);\n        start();\n    }\n    function pong() {\n        clearTimeout(pongTimeout);\n        reset();\n    }\n    ws.addEventListener('open', start);\n    ws.addEventListener('message', ({ data })=>{\n        clearTimeout(pingTimeout);\n        start();\n        if (data === 'PONG') {\n            pong();\n        }\n    });\n    ws.addEventListener('close', ()=>{\n        clearTimeout(pingTimeout);\n        clearTimeout(pongTimeout);\n    });\n}\n/**\n * Manages a WebSocket connection with support for reconnection, keep-alive mechanisms,\n * and observable state tracking.\n */ class WsConnection {\n    get ws() {\n        return this.wsObservable.get();\n    }\n    set ws(ws) {\n        this.wsObservable.next(ws);\n    }\n    /**\n   * Checks if the WebSocket connection is open and ready to communicate.\n   */ isOpen() {\n        return !!this.ws && this.ws.readyState === this.WebSocketPonyfill.OPEN && !this.openPromise;\n    }\n    /**\n   * Checks if the WebSocket connection is closed or in the process of closing.\n   */ isClosed() {\n        return !!this.ws && (this.ws.readyState === this.WebSocketPonyfill.CLOSING || this.ws.readyState === this.WebSocketPonyfill.CLOSED);\n    }\n    async open() {\n        if (this.openPromise) return this.openPromise;\n        this.id = ++WsConnection.connectCount;\n        const wsPromise = prepareUrl(this.urlOptions).then((url)=>new this.WebSocketPonyfill(url));\n        this.openPromise = wsPromise.then(async (ws)=>{\n            this.ws = ws;\n            // Setup ping listener\n            ws.addEventListener('message', function({ data }) {\n                if (data === 'PING') {\n                    this.send('PONG');\n                }\n            });\n            if (this.keepAliveOpts.enabled) {\n                setupPingInterval(ws, this.keepAliveOpts);\n            }\n            ws.addEventListener('close', ()=>{\n                if (this.ws === ws) {\n                    this.ws = null;\n                }\n            });\n            await asyncWsOpen(ws);\n            if (this.urlOptions.connectionParams) {\n                ws.send(await buildConnectionMessage(this.urlOptions.connectionParams));\n            }\n        });\n        try {\n            await this.openPromise;\n        } finally{\n            this.openPromise = null;\n        }\n    }\n    /**\n   * Closes the WebSocket connection gracefully.\n   * Waits for any ongoing open operation to complete before closing.\n   */ async close() {\n        try {\n            await this.openPromise;\n        } finally{\n            this.ws?.close();\n        }\n    }\n    constructor(opts){\n        _define_property(this, \"id\", ++WsConnection.connectCount);\n        _define_property(this, \"WebSocketPonyfill\", void 0);\n        _define_property(this, \"urlOptions\", void 0);\n        _define_property(this, \"keepAliveOpts\", void 0);\n        _define_property(this, \"wsObservable\", behaviorSubject(null));\n        /**\n   * Manages the WebSocket opening process, ensuring that only one open operation\n   * occurs at a time. Tracks the ongoing operation with `openPromise` to avoid\n   * redundant calls and ensure proper synchronization.\n   *\n   * Sets up the keep-alive mechanism and necessary event listeners for the connection.\n   *\n   * @returns A promise that resolves once the WebSocket connection is successfully opened.\n   */ _define_property(this, \"openPromise\", null);\n        this.WebSocketPonyfill = opts.WebSocketPonyfill ?? WebSocket;\n        if (!this.WebSocketPonyfill) {\n            throw new Error(\"No WebSocket implementation found - you probably don't want to use this on the server, but if you do you need to pass a `WebSocket`-ponyfill\");\n        }\n        this.urlOptions = opts.urlOptions;\n        this.keepAliveOpts = opts.keepAlive;\n    }\n}\n_define_property(WsConnection, \"connectCount\", 0);\n/**\n * Provides a backward-compatible representation of the connection state.\n */ function backwardCompatibility(connection) {\n    if (connection.isOpen()) {\n        return {\n            id: connection.id,\n            state: 'open',\n            ws: connection.ws\n        };\n    }\n    if (connection.isClosed()) {\n        return {\n            id: connection.id,\n            state: 'closed',\n            ws: connection.ws\n        };\n    }\n    if (!connection.ws) {\n        return null;\n    }\n    return {\n        id: connection.id,\n        state: 'connecting',\n        ws: connection.ws\n    };\n}\n\nexport { WsConnection, backwardCompatibility };\n", "import { observable, behaviorSubject } from '@trpc/server/observable';\nimport { TRPC_ERROR_CODES_BY_KEY } from '@trpc/server/rpc';\nimport { sseStreamConsumer, run } from '@trpc/server/unstable-core-do-not-import';\nimport { inputWithTrackedEventId } from '../internals/inputWithTrackedEventId.mjs';\nimport { raceAbortSignals } from '../internals/signals.mjs';\nimport { TRPCClientError } from '../TRPCClientError.mjs';\nimport { getTransformer } from '../internals/transformer.mjs';\nimport { getUrl } from './internals/httpUtils.mjs';\nimport { resultOf } from './internals/urlWithConnectionParams.mjs';\n\nasync function urlWithConnectionParams(opts) {\n    let url = await resultOf(opts.url);\n    if (opts.connectionParams) {\n        const params = await resultOf(opts.connectionParams);\n        const prefix = url.includes('?') ? '&' : '?';\n        url += prefix + 'connectionParams=' + encodeURIComponent(JSON.stringify(params));\n    }\n    return url;\n}\n/**\n * tRPC error codes that are considered retryable\n * With out of the box SSE, the client will reconnect when these errors are encountered\n */ const codes5xx = [\n    TRPC_ERROR_CODES_BY_KEY.BAD_GATEWAY,\n    TRPC_ERROR_CODES_BY_KEY.SERVICE_UNAVAILABLE,\n    TRPC_ERROR_CODES_BY_KEY.GATEWAY_TIMEOUT,\n    TRPC_ERROR_CODES_BY_KEY.INTERNAL_SERVER_ERROR\n];\n/**\n * @see https://trpc.io/docs/client/links/httpSubscriptionLink\n */ function httpSubscriptionLink(opts) {\n    const transformer = getTransformer(opts.transformer);\n    return ()=>{\n        return ({ op })=>{\n            return observable((observer)=>{\n                const { type, path, input } = op;\n                /* istanbul ignore if -- @preserve */ if (type !== 'subscription') {\n                    throw new Error('httpSubscriptionLink only supports subscriptions');\n                }\n                let lastEventId = undefined;\n                const ac = new AbortController();\n                const signal = raceAbortSignals(op.signal, ac.signal);\n                const eventSourceStream = sseStreamConsumer({\n                    url: async ()=>getUrl({\n                            transformer,\n                            url: await urlWithConnectionParams(opts),\n                            input: inputWithTrackedEventId(input, lastEventId),\n                            path,\n                            type,\n                            signal: null\n                        }),\n                    init: ()=>resultOf(opts.eventSourceOptions, {\n                            op\n                        }),\n                    signal,\n                    deserialize: transformer.output.deserialize,\n                    EventSource: opts.EventSource ?? globalThis.EventSource\n                });\n                const connectionState = behaviorSubject({\n                    type: 'state',\n                    state: 'connecting',\n                    error: null\n                });\n                const connectionSub = connectionState.subscribe({\n                    next (state) {\n                        observer.next({\n                            result: state\n                        });\n                    }\n                });\n                run(async ()=>{\n                    for await (const chunk of eventSourceStream){\n                        switch(chunk.type){\n                            case 'ping':\n                                break;\n                            case 'data':\n                                const chunkData = chunk.data;\n                                let result;\n                                if (chunkData.id) {\n                                    // if the `tracked()`-helper is used, we always have an `id` field\n                                    lastEventId = chunkData.id;\n                                    result = {\n                                        id: chunkData.id,\n                                        data: chunkData\n                                    };\n                                } else {\n                                    result = {\n                                        data: chunkData.data\n                                    };\n                                }\n                                observer.next({\n                                    result,\n                                    context: {\n                                        eventSource: chunk.eventSource\n                                    }\n                                });\n                                break;\n                            case 'connected':\n                                {\n                                    observer.next({\n                                        result: {\n                                            type: 'started'\n                                        },\n                                        context: {\n                                            eventSource: chunk.eventSource\n                                        }\n                                    });\n                                    connectionState.next({\n                                        type: 'state',\n                                        state: 'pending',\n                                        error: null\n                                    });\n                                    break;\n                                }\n                            case 'serialized-error':\n                                {\n                                    const error = TRPCClientError.from({\n                                        error: chunk.error\n                                    });\n                                    if (codes5xx.includes(chunk.error.code)) {\n                                        //\n                                        connectionState.next({\n                                            type: 'state',\n                                            state: 'connecting',\n                                            error\n                                        });\n                                        break;\n                                    }\n                                    //\n                                    // non-retryable error, cancel the subscription\n                                    throw error;\n                                }\n                            case 'connecting':\n                                {\n                                    const lastState = connectionState.get();\n                                    const error = chunk.event && TRPCClientError.from(chunk.event);\n                                    if (!error && lastState.state === 'connecting') {\n                                        break;\n                                    }\n                                    connectionState.next({\n                                        type: 'state',\n                                        state: 'connecting',\n                                        error\n                                    });\n                                    break;\n                                }\n                            case 'timeout':\n                                {\n                                    connectionState.next({\n                                        type: 'state',\n                                        state: 'connecting',\n                                        error: new TRPCClientError(`Timeout of ${chunk.ms}ms reached while waiting for a response`)\n                                    });\n                                }\n                        }\n                    }\n                    observer.next({\n                        result: {\n                            type: 'stopped'\n                        }\n                    });\n                    connectionState.next({\n                        type: 'state',\n                        state: 'idle',\n                        error: null\n                    });\n                    observer.complete();\n                }).catch((error)=>{\n                    observer.error(TRPCClientError.from(error));\n                });\n                return ()=>{\n                    observer.complete();\n                    ac.abort();\n                    connectionSub.unsubscribe();\n                };\n            });\n        };\n    };\n}\n\nexport { httpSubscriptionLink };\n", "import { skipToken } from '@tanstack/react-query';\nimport { isObject, isFunction } from '@trpc/server/unstable-core-do-not-import';\n\n/**\n * @internal\n */ function createTRPCOptionsResult(value) {\n    const path = value.path.join('.');\n    return {\n        path\n    };\n}\n/**\n * @internal\n */ function getClientArgs(queryKey, opts, infiniteParams) {\n    const path = queryKey[0];\n    let input = queryKey[1]?.input;\n    if (infiniteParams) {\n        input = {\n            ...input ?? {},\n            ...infiniteParams.pageParam !== undefined ? {\n                cursor: infiniteParams.pageParam\n            } : {},\n            direction: infiniteParams.direction\n        };\n    }\n    return [\n        path.join('.'),\n        input,\n        opts?.trpc\n    ];\n}\n/**\n * @internal\n */ async function buildQueryFromAsyncIterable(asyncIterable, queryClient, queryKey) {\n    const queryCache = queryClient.getQueryCache();\n    const query = queryCache.build(queryClient, {\n        queryKey\n    });\n    query.setState({\n        data: [],\n        status: 'success'\n    });\n    const aggregate = [];\n    for await (const value of asyncIterable){\n        aggregate.push(value);\n        query.setState({\n            data: [\n                ...aggregate\n            ]\n        });\n    }\n    return aggregate;\n}\n/**\n * To allow easy interactions with groups of related queries, such as\n * invalidating all queries of a router, we use an array as the path when\n * storing in tanstack query.\n *\n * @internal\n */ function getQueryKeyInternal(path, input, type) {\n    // Construct a query key that is easy to destructure and flexible for\n    // partial selecting etc.\n    // https://github.com/trpc/trpc/issues/3128\n    // some parts of the path may be dot-separated, split them up\n    const splitPath = path.flatMap((part)=>part.split('.'));\n    if (!input && (!type || type === 'any')) {\n        // this matches also all mutations (see `getMutationKeyInternal`)\n        // for `utils.invalidate()` to match all queries (including vanilla react-query)\n        // we don't want nested array if path is empty, i.e. `[]` instead of `[[]]`\n        return splitPath.length ? [\n            splitPath\n        ] : [];\n    }\n    if (type === 'infinite' && isObject(input) && ('direction' in input || 'cursor' in input)) {\n        const { cursor: _, direction: __, ...inputWithoutCursorAndDirection } = input;\n        return [\n            splitPath,\n            {\n                input: inputWithoutCursorAndDirection,\n                type: 'infinite'\n            }\n        ];\n    }\n    return [\n        splitPath,\n        {\n            ...typeof input !== 'undefined' && input !== skipToken && {\n                input: input\n            },\n            ...type && type !== 'any' && {\n                type: type\n            }\n        }\n    ];\n}\n/**\n * @internal\n */ function getMutationKeyInternal(path) {\n    // some parts of the path may be dot-separated, split them up\n    const splitPath = path.flatMap((part)=>part.split('.'));\n    return splitPath.length ? [\n        splitPath\n    ] : [];\n}\n/**\n * @internal\n */ function unwrapLazyArg(valueOrLazy) {\n    return isFunction(valueOrLazy) ? valueOrLazy() : valueOrLazy;\n}\n\nexport { buildQueryFromAsyncIterable, createTRPCOptionsResult, getClientArgs, getMutationKeyInternal, getQueryKeyInternal, unwrapLazyArg };\n", "import { infiniteQueryOptions, skipToken } from '@tanstack/react-query';\nimport { createTRPCOptionsResult, getClientArgs } from './utils.mjs';\n\nfunction trpcInfiniteQueryOptions(args) {\n    const { input, query, path, queryKey, opts } = args;\n    const inputIsSkipToken = input === skipToken;\n    const queryFn = async (queryFnContext)=>{\n        const actualOpts = {\n            ...opts,\n            trpc: {\n                ...opts?.trpc,\n                ...opts?.trpc?.abortOnUnmount ? {\n                    signal: queryFnContext.signal\n                } : {\n                    signal: null\n                }\n            }\n        };\n        const result = await query(...getClientArgs(queryKey, actualOpts, {\n            direction: queryFnContext.direction,\n            pageParam: queryFnContext.pageParam\n        }));\n        return result;\n    };\n    return Object.assign(infiniteQueryOptions({\n        ...opts,\n        queryKey,\n        queryFn: inputIsSkipToken ? skipToken : queryFn,\n        initialPageParam: opts?.initialCursor ?? input?.cursor\n    }), {\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    });\n}\n\nexport { trpcInfiniteQueryOptions };\n", "import { unwrapLazyArg, getMutationKeyInternal, createTRPCOptionsResult, getClientArgs } from './utils.mjs';\n\n/**\n * @internal\n */ function trpcMutationOptions(args) {\n    const { mutate, path, opts, overrides } = args;\n    const queryClient = unwrapLazyArg(args.queryClient);\n    const mutationKey = getMutationKeyInternal(path);\n    const defaultOpts = queryClient.defaultMutationOptions(queryClient.getMutationDefaults(mutationKey));\n    const mutationSuccessOverride = overrides?.onSuccess ?? ((options)=>options.originalFn());\n    const mutationFn = async (input)=>{\n        const result = await mutate(...getClientArgs([\n            path,\n            {\n                input\n            }\n        ], opts));\n        return result;\n    };\n    return {\n        ...opts,\n        mutationKey: mutationKey,\n        mutationFn,\n        onSuccess (...args) {\n            const originalFn = ()=>opts?.onSuccess?.(...args) ?? defaultOpts?.onSuccess?.(...args);\n            return mutationSuccessOverride({\n                originalFn,\n                queryClient,\n                meta: opts?.meta ?? defaultOpts?.meta ?? {}\n            });\n        },\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    };\n}\n\nexport { trpcMutationOptions };\n", "import { queryOptions, skipToken } from '@tanstack/react-query';\nimport { isAsyncIterable } from '@trpc/server/unstable-core-do-not-import';\nimport { unwrapLazyArg, createTRPCOptionsResult, getClientArgs, buildQueryFromAsyncIterable } from './utils.mjs';\n\n/**\n * @internal\n */ function trpcQueryOptions(args) {\n    const { input, query, path, queryKey, opts } = args;\n    const queryClient = unwrapLazyArg(args.queryClient);\n    const inputIsSkipToken = input === skipToken;\n    const queryFn = async (queryFnContext)=>{\n        const actualOpts = {\n            ...opts,\n            trpc: {\n                ...opts?.trpc,\n                ...opts?.trpc?.abortOnUnmount ? {\n                    signal: queryFnContext.signal\n                } : {\n                    signal: null\n                }\n            }\n        };\n        const result = await query(...getClientArgs(queryKey, actualOpts));\n        if (isAsyncIterable(result)) {\n            return buildQueryFromAsyncIterable(result, queryClient, queryKey);\n        }\n        return result;\n    };\n    return Object.assign(queryOptions({\n        ...opts,\n        queryKey,\n        queryFn: inputIsSkipToken ? skipToken : queryFn\n    }), {\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    });\n}\n\nexport { trpcQueryOptions };\n", "import { hashKey, skipToken } from '@tanstack/react-query';\nimport * as React from 'react';\nimport { createTRPCOptionsResult } from './utils.mjs';\n\n/**\n * @internal\n */ const trpcSubscriptionOptions = (args)=>{\n    const { subscribe, path, queryKey, opts } = args;\n    const input = queryKey[1]?.input;\n    const enabled = 'enabled' in opts ? !!opts.enabled : input !== skipToken;\n    const _subscribe = (innerOpts)=>{\n        return subscribe(path.join('.'), input ?? undefined, innerOpts);\n    };\n    return {\n        ...opts,\n        enabled,\n        subscribe: _subscribe,\n        queryKey,\n        trpc: createTRPCOptionsResult({\n            path\n        })\n    };\n};\nfunction useSubscription(opts) {\n    const optsRef = React.useRef(opts);\n    optsRef.current = opts;\n    const trackedProps = React.useRef(new Set([]));\n    const addTrackedProp = React.useCallback((key)=>{\n        trackedProps.current.add(key);\n    }, []);\n    const currentSubscriptionRef = React.useRef(()=>{\n    // noop\n    });\n    const reset = React.useCallback(()=>{\n        // unsubscribe from the previous subscription\n        currentSubscriptionRef.current?.();\n        updateState(getInitialState);\n        if (!opts.enabled) {\n            return;\n        }\n        const subscription = opts.subscribe({\n            onStarted: ()=>{\n                optsRef.current.onStarted?.();\n                updateState((prev)=>({\n                        ...prev,\n                        status: 'pending',\n                        error: null\n                    }));\n            },\n            onData: (data)=>{\n                optsRef.current.onData?.(data);\n                updateState((prev)=>({\n                        ...prev,\n                        status: 'pending',\n                        data,\n                        error: null\n                    }));\n            },\n            onError: (error)=>{\n                optsRef.current.onError?.(error);\n                updateState((prev)=>({\n                        ...prev,\n                        status: 'error',\n                        error\n                    }));\n            },\n            onConnectionStateChange: (result)=>{\n                updateState((prev)=>{\n                    switch(result.state){\n                        case 'connecting':\n                            return {\n                                ...prev,\n                                status: 'connecting',\n                                error: result.error\n                            };\n                        case 'pending':\n                            // handled in onStarted\n                            return prev;\n                        case 'idle':\n                            return {\n                                ...prev,\n                                status: 'idle',\n                                data: undefined,\n                                error: null\n                            };\n                    }\n                });\n            }\n        });\n        currentSubscriptionRef.current = ()=>{\n            subscription.unsubscribe();\n        };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        hashKey(opts.queryKey),\n        opts.enabled\n    ]);\n    const getInitialState = React.useCallback(()=>{\n        return opts.enabled ? {\n            data: undefined,\n            error: null,\n            status: 'connecting',\n            reset\n        } : {\n            data: undefined,\n            error: null,\n            status: 'idle',\n            reset\n        };\n    }, [\n        opts.enabled,\n        reset\n    ]);\n    const resultRef = React.useRef(getInitialState());\n    const [state, setState] = React.useState(trackResult(resultRef.current, addTrackedProp));\n    state.reset = reset;\n    const updateState = React.useCallback((callback)=>{\n        const prev = resultRef.current;\n        const next = resultRef.current = callback(prev);\n        let shouldUpdate = false;\n        for (const key of trackedProps.current){\n            if (prev[key] !== next[key]) {\n                shouldUpdate = true;\n                break;\n            }\n        }\n        if (shouldUpdate) {\n            setState(trackResult(next, addTrackedProp));\n        }\n    }, [\n        addTrackedProp\n    ]);\n    React.useEffect(()=>{\n        if (!opts.enabled) {\n            return;\n        }\n        reset();\n        return ()=>{\n            currentSubscriptionRef.current?.();\n        };\n    }, [\n        reset,\n        opts.enabled\n    ]);\n    return state;\n}\nfunction trackResult(result, onTrackResult) {\n    const trackedResult = new Proxy(result, {\n        get (target, prop) {\n            onTrackResult(prop);\n            return target[prop];\n        }\n    });\n    return trackedResult;\n}\n\nexport { trpcSubscriptionOptions, useSubscription };\n", "import { TRPCUntypedClient, getUntypedClient } from '@trpc/client';\nimport { createTRPCRecursiveProxy, callTRPCProcedure } from '@trpc/server';\nimport { trpcInfiniteQueryOptions } from './infiniteQueryOptions.mjs';\nimport { trpcMutationOptions } from './mutationOptions.mjs';\nimport { trpcQueryOptions } from './queryOptions.mjs';\nimport { trpcSubscriptionOptions } from './subscriptionOptions.mjs';\nimport { getQueryKeyInternal, getMutationKeyInternal, unwrapLazyArg } from './utils.mjs';\n\n/**\n * Create a typed proxy from your router types. Can also be used on the server.\n *\n * @see https://trpc.io/docs/client/tanstack-react-query/setup#3b-setup-without-react-context\n * @see https://trpc.io/docs/client/tanstack-react-query/server-components#5-create-a-trpc-caller-for-server-components\n */ function createTRPCOptionsProxy(opts) {\n    const callIt = (type)=>{\n        return (path, input, trpcOpts)=>{\n            if ('router' in opts) {\n                return Promise.resolve(unwrapLazyArg(opts.ctx)).then((ctx)=>callTRPCProcedure({\n                        router: opts.router,\n                        path: path,\n                        getRawInput: async ()=>input,\n                        ctx: ctx,\n                        type: type,\n                        signal: undefined\n                    }));\n            }\n            const untypedClient = opts.client instanceof TRPCUntypedClient ? opts.client : getUntypedClient(opts.client);\n            return untypedClient[type](path, input, trpcOpts);\n        };\n    };\n    return createTRPCRecursiveProxy(({ args, path: _path })=>{\n        const path = [\n            ..._path\n        ];\n        const utilName = path.pop();\n        const [arg1, arg2] = args;\n        const contextMap = {\n            '~types': undefined,\n            pathKey: ()=>{\n                return getQueryKeyInternal(path);\n            },\n            pathFilter: ()=>{\n                return {\n                    ...arg1,\n                    queryKey: getQueryKeyInternal(path)\n                };\n            },\n            queryOptions: ()=>{\n                return trpcQueryOptions({\n                    input: arg1,\n                    opts: arg2,\n                    path,\n                    queryClient: opts.queryClient,\n                    queryKey: getQueryKeyInternal(path, arg1, 'query'),\n                    query: callIt('query')\n                });\n            },\n            queryKey: ()=>{\n                return getQueryKeyInternal(path, arg1, 'query');\n            },\n            queryFilter: ()=>{\n                return {\n                    ...arg2,\n                    queryKey: getQueryKeyInternal(path, arg1, 'query')\n                };\n            },\n            infiniteQueryOptions: ()=>{\n                return trpcInfiniteQueryOptions({\n                    input: arg1,\n                    opts: arg2,\n                    path,\n                    queryClient: opts.queryClient,\n                    queryKey: getQueryKeyInternal(path, arg1, 'infinite'),\n                    query: callIt('query')\n                });\n            },\n            infiniteQueryKey: ()=>{\n                return getQueryKeyInternal(path, arg1, 'infinite');\n            },\n            infiniteQueryFilter: ()=>{\n                return {\n                    ...arg2,\n                    queryKey: getQueryKeyInternal(path, arg1, 'infinite')\n                };\n            },\n            mutationOptions: ()=>{\n                return trpcMutationOptions({\n                    opts: arg1,\n                    path,\n                    queryClient: opts.queryClient,\n                    mutate: callIt('mutation'),\n                    overrides: opts.overrides?.mutations\n                });\n            },\n            mutationKey: ()=>{\n                return getMutationKeyInternal(path);\n            },\n            subscriptionOptions: ()=>{\n                return trpcSubscriptionOptions({\n                    opts: arg2,\n                    path,\n                    queryKey: getQueryKeyInternal(path, arg1, 'any'),\n                    subscribe: callIt('subscription')\n                });\n            }\n        };\n        return contextMap[utilName]();\n    });\n}\n\nexport { createTRPCOptionsProxy };\n"],
  "mappings": ";;;;;;;;;;;;;;;AAAA,IAAAA,SAAuB;;;ACGR,SAAS,WAAW,WAAW;AAC1C,QAAM,OAAO;AAAA,IACT,UAAW,UAAU;AACjB,UAAI,cAAc;AAClB,UAAI,SAAS;AACb,UAAI,eAAe;AACnB,UAAI,sBAAsB;AAC1B,eAAS,cAAc;AACnB,YAAI,gBAAgB,MAAM;AACtB,gCAAsB;AACtB;AAAA,QACJ;AACA,YAAI,cAAc;AACd;AAAA,QACJ;AACA,uBAAe;AACf,YAAI,OAAO,gBAAgB,YAAY;AACnC,sBAAY;AAAA,QAChB,WAAW,aAAa;AACpB,sBAAY,YAAY;AAAA,QAC5B;AAAA,MACJ;AACA,oBAAc,UAAU;AAAA,QACpB,KAAM,OAAO;AA1B7B,cAAAC;AA2BoB,cAAI,QAAQ;AACR;AAAA,UACJ;AACA,WAAAA,MAAA,SAAS,SAAT,gBAAAA,IAAA,eAAgB;AAAA,QACpB;AAAA,QACA,MAAO,KAAK;AAhC5B,cAAAA;AAiCoB,cAAI,QAAQ;AACR;AAAA,UACJ;AACA,mBAAS;AACT,WAAAA,MAAA,SAAS,UAAT,gBAAAA,IAAA,eAAiB;AACjB,sBAAY;AAAA,QAChB;AAAA,QACA,WAAY;AAxC5B,cAAAA;AAyCoB,cAAI,QAAQ;AACR;AAAA,UACJ;AACA,mBAAS;AACT,WAAAA,MAAA,SAAS,aAAT,gBAAAA,IAAA;AACA,sBAAY;AAAA,QAChB;AAAA,MACJ,CAAC;AACD,UAAI,qBAAqB;AACrB,oBAAY;AAAA,MAChB;AACA,aAAO;AAAA,QACH;AAAA,MACJ;AAAA,IACJ;AAAA,IACA,QAAS,YAAY;AACjB,aAAO,WAAW,OAAO,aAAa,IAAI;AAAA,IAC9C;AAAA,EACJ;AACA,SAAO;AACX;AACA,SAAS,YAAY,MAAM,IAAI;AAC3B,SAAO,GAAG,IAAI;AAClB;AACiB,SAAS,oBAAoBC,aAAY;AACtD,QAAM,KAAK,IAAI,gBAAgB;AAC/B,QAAM,UAAU,IAAI,QAAQ,CAAC,SAAS,WAAS;AAC3C,QAAI,SAAS;AACb,aAAS,SAAS;AACd,UAAI,QAAQ;AACR;AAAA,MACJ;AACA,eAAS;AACT,WAAK,YAAY;AAAA,IACrB;AACA,OAAG,OAAO,iBAAiB,SAAS,MAAI;AACpC,aAAO,GAAG,OAAO,MAAM;AAAA,IAC3B,CAAC;AACD,UAAM,OAAOA,YAAW,UAAU;AAAA,MAC9B,KAAM,MAAM;AACR,iBAAS;AACT,gBAAQ,IAAI;AACZ,eAAO;AAAA,MACX;AAAA,MACA,MAAO,MAAM;AACT,eAAO,IAAI;AAAA,MACf;AAAA,MACA,WAAY;AACR,WAAG,MAAM;AACT,eAAO;AAAA,MACX;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACD,SAAO;AACX;;;AC1EA,SAAS,MAAM,OAAO;AAClB,SAAO,CAAC,WAAS;AACb,QAAI,WAAW;AACf,QAAI,eAAe;AACnB,UAAM,YAAY,CAAC;AACnB,aAAS,gBAAgB;AACrB,UAAI,cAAc;AACd;AAAA,MACJ;AACA,qBAAe,OAAO,UAAU;AAAA,QAC5B,KAAM,OAAO;AA/B7B,cAAAC;AAgCoB,qBAAW,YAAY,WAAU;AAC7B,aAAAA,MAAA,SAAS,SAAT,gBAAAA,IAAA,eAAgB;AAAA,UACpB;AAAA,QACJ;AAAA,QACA,MAAO,OAAO;AApC9B,cAAAA;AAqCoB,qBAAW,YAAY,WAAU;AAC7B,aAAAA,MAAA,SAAS,UAAT,gBAAAA,IAAA,eAAiB;AAAA,UACrB;AAAA,QACJ;AAAA,QACA,WAAY;AAzC5B,cAAAA;AA0CoB,qBAAW,YAAY,WAAU;AAC7B,aAAAA,MAAA,SAAS,aAAT,gBAAAA,IAAA;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AACA,aAAS,gBAAgB;AAErB,UAAI,aAAa,KAAK,cAAc;AAChC,cAAM,OAAO;AACb,uBAAe;AACf,aAAK,YAAY;AAAA,MACrB;AAAA,IACJ;AACA,WAAO,WAAW,CAAC,eAAa;AAC5B;AACA,gBAAU,KAAK,UAAU;AACzB,oBAAc;AACd,aAAO;AAAA,QACH,cAAe;AACX;AACA,wBAAc;AACd,gBAAM,QAAQ,UAAU,UAAU,CAAC,MAAI,MAAM,UAAU;AACvD,cAAI,QAAQ,IAAI;AACZ,sBAAU,OAAO,OAAO,CAAC;AAAA,UAC7B;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;AAqBA,IAAM,sBAAsB,OAAO;;;ACvF/B,SAAS,gBAAgB,cAAc;AACvC,MAAI,QAAQ;AACZ,QAAM,eAAe,CAAC;AACtB,QAAM,cAAc,CAAC,aAAW;AAC5B,QAAI,UAAU,QAAW;AACrB,eAAS,KAAK,KAAK;AAAA,IACvB;AACA,iBAAa,KAAK,QAAQ;AAAA,EAC9B;AACA,QAAM,iBAAiB,CAAC,aAAW;AAC/B,iBAAa,OAAO,aAAa,QAAQ,QAAQ,GAAG,CAAC;AAAA,EACzD;AACA,QAAM,MAAM,WAAW,CAAC,aAAW;AAC/B,gBAAY,QAAQ;AACpB,WAAO,MAAI;AACP,qBAAe,QAAQ;AAAA,IAC3B;AAAA,EACJ,CAAC;AACD,MAAI,OAAO,CAAC,cAAY;AACpB,QAAI,UAAU,WAAW;AACrB;AAAA,IACJ;AACA,YAAQ;AACR,eAAW,YAAY,cAAa;AAChC,eAAS,KAAK,SAAS;AAAA,IAC3B;AAAA,EACJ;AACA,MAAI,MAAM,MAAI;AACd,SAAO;AACX;;;ACjCiB,SAAS,YAAY,MAAM;AACxC,SAAO,WAAW,CAAC,aAAW;AAC1B,aAAS,QAAQ,QAAQ,GAAG,KAAK,KAAK,IAAI;AACtC,YAAM,OAAO,KAAK,MAAM,KAAK;AAC7B,UAAI,CAAC,MAAM;AACP,cAAM,IAAI,MAAM,kEAAkE;AAAA,MACtF;AACA,YAAM,eAAe,KAAK;AAAA,QACtB;AAAA,QACA,KAAM,QAAQ;AACV,gBAAM,eAAe,QAAQ,QAAQ,GAAG,MAAM;AAC9C,iBAAO;AAAA,QACX;AAAA,MACJ,CAAC;AACD,aAAO;AAAA,IACX;AACA,UAAM,OAAO,QAAQ;AACrB,WAAO,KAAK,UAAU,QAAQ;AAAA,EAClC,CAAC;AACL;;;ACrBA,IAAM,OAAO,MAAI;AAEjB;AACA,IAAM,oBAAoB,CAAC,QAAM;AAC7B,MAAI,OAAO,QAAQ;AACf,WAAO,OAAO,GAAG;AAAA,EACrB;AACJ;AACA,SAAS,iBAAiB,UAAU,MAAM,MAAM;AAC5C,MAAI,OAAO;AACX,QAAM,WAAW,KAAK,KAAK,GAAG;AAC9B,GAAC,QAAQ,MAAM,YAAY,QAAQ,MAAM,MAAM,SAAS,IAAI,IAAI,MAAM,MAAM;AAAA,IACxE,IAAK,MAAM,KAAK;AACZ,UAAI,OAAO,QAAQ,YAAY,QAAQ,QAAQ;AAG3C,eAAO;AAAA,MACX;AACA,aAAO,iBAAiB,UAAU;AAAA,QAC9B,GAAG;AAAA,QACH;AAAA,MACJ,GAAG,IAAI;AAAA,IACX;AAAA,IACA,MAAO,IAAI,IAAI,MAAM;AACjB,YAAM,aAAa,KAAK,KAAK,SAAS,CAAC;AACvC,UAAI,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACJ;AAEA,UAAI,eAAe,QAAQ;AACvB,eAAO;AAAA,UACH,MAAM,KAAK,UAAU,IAAI;AAAA,YACrB,KAAK,CAAC;AAAA,UACV,IAAI,CAAC;AAAA,UACL,MAAM,KAAK,MAAM,GAAG,EAAE;AAAA,QAC1B;AAAA,MACJ,WAAW,eAAe,SAAS;AAC/B,eAAO;AAAA,UACH,MAAM,KAAK,UAAU,IAAI,KAAK,CAAC,IAAI,CAAC;AAAA,UACpC,MAAM,KAAK,MAAM,GAAG,EAAE;AAAA,QAC1B;AAAA,MACJ;AACA,wBAAkB,KAAK,IAAI;AAC3B,wBAAkB,KAAK,IAAI;AAC3B,aAAO,SAAS,IAAI;AAAA,IACxB;AAAA,EACJ,CAAC;AACD,SAAO,KAAK,QAAQ;AACxB;AAKI,IAAM,uBAAuB,CAAC,aAAW,iBAAiB,UAAU,CAAC,GAAG,uBAAO,OAAO,IAAI,CAAC;;;ACtD/F,IAAM,mBAAmB,CAAC,EAAE,MAAM,MAAI;AAClC,SAAO;AACX;;;ACII,IAAM,0BAA0B;AAAA;AAAA;AAAA;AAAA;AAAA,EAI9B,aAAa;AAAA;AAAA;AAAA;AAAA,EAGb,aAAa;AAAA;AAAA,EAEf,uBAAuB;AAAA,EACvB,iBAAiB;AAAA,EACjB,aAAa;AAAA,EACb,qBAAqB;AAAA,EACrB,iBAAiB;AAAA;AAAA,EAEjB,cAAc;AAAA,EACd,WAAW;AAAA,EACX,WAAW;AAAA,EACX,sBAAsB;AAAA,EACtB,SAAS;AAAA,EACT,UAAU;AAAA,EACV,qBAAqB;AAAA,EACrB,mBAAmB;AAAA,EACnB,wBAAwB;AAAA,EACxB,uBAAuB;AAAA,EACvB,mBAAmB;AAAA,EACnB,uBAAuB;AAC3B;;;ACjCiB,IAAM,cAAc,OAAO;AAIxC,SAAS,sBAAsB,SAAS,MAAM;AAC9C,QAAM,SAAS,OAAO,OAAO,uBAAO,OAAO,IAAI,GAAG,IAAI;AACtD,aAAW,aAAa,MAAK;AACzB,eAAU,OAAO,WAAU;AACvB,UAAI,OAAO,UAAU,OAAO,GAAG,MAAM,UAAU,GAAG,GAAG;AACjD,cAAM,IAAI,MAAM,iBAAiB,GAAG,EAAE;AAAA,MAC1C;AACA,aAAO,GAAG,IAAI,UAAU,GAAG;AAAA,IAC/B;AAAA,EACJ;AACA,SAAO;AACX;AAII,SAAS,SAAS,OAAO;AACzB,SAAO,CAAC,CAAC,SAAS,CAAC,MAAM,QAAQ,KAAK,KAAK,OAAO,UAAU;AAChE;AACA,SAAS,WAAW,IAAI;AACpB,SAAO,OAAO,OAAO;AACzB;AAII,SAAS,cAAc,KAAK;AAC5B,SAAO,OAAO,OAAO,uBAAO,OAAO,IAAI,GAAG,GAAG;AACjD;AACA,IAAM,0BAA0B,OAAO,WAAW,cAAc,CAAC,CAAC,OAAO;AACzE,SAAS,gBAAgB,OAAO;AAC5B,SAAO,2BAA2B,SAAS,KAAK,KAAK,OAAO,iBAAiB;AACjF;;;AChCA,SAAS,iBAAiB,KAAK,KAAK,OAAO;AACvC,MAAI,OAAO,KAAK;AACZ,WAAO,eAAe,KAAK,KAAK;AAAA,MAC5B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,IACd,CAAC;AAAA,EACL,OAAO;AACH,QAAI,GAAG,IAAI;AAAA,EACf;AACA,SAAO;AACX;AACA,IAAM,oBAAN,cAAgC,MAAM;AACtC;AACA,SAAS,oBAAoB,OAAO;AAChC,MAAI,iBAAiB,OAAO;AACxB,WAAO;AAAA,EACX;AACA,QAAM,OAAO,OAAO;AACpB,MAAI,SAAS,eAAe,SAAS,cAAc,UAAU,MAAM;AAC/D,WAAO;AAAA,EACX;AAEA,MAAI,SAAS,UAAU;AAEnB,WAAO,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,EAClC;AAEA,MAAI,SAAS,KAAK,GAAG;AACjB,UAAM,MAAM,IAAI,kBAAkB;AAClC,eAAU,OAAO,OAAM;AACnB,UAAI,GAAG,IAAI,MAAM,GAAG;AAAA,IACxB;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,wBAAwB,OAAO;AACpC,MAAI,iBAAiB,WAAW;AAC5B,WAAO;AAAA,EACX;AACA,MAAI,iBAAiB,SAAS,MAAM,SAAS,aAAa;AAEtD,WAAO;AAAA,EACX;AACA,QAAM,YAAY,IAAI,UAAU;AAAA,IAC5B,MAAM;AAAA,IACN;AAAA,EACJ,CAAC;AAED,MAAI,iBAAiB,SAAS,MAAM,OAAO;AACvC,cAAU,QAAQ,MAAM;AAAA,EAC5B;AACA,SAAO;AACX;AACA,IAAM,YAAN,cAAwB,MAAM;AAAA,EAC1B,YAAY,MAAK;AACb,UAAM,QAAQ,oBAAoB,KAAK,KAAK;AAC5C,UAAM,UAAU,KAAK,YAAW,+BAAO,YAAW,KAAK;AAGvD,UAAM,SAAS;AAAA,MACX;AAAA,IACJ,CAAC;AAAA;AAAA,IAED,iBAAiB,MAAM,SAAS,MAAM,GAAG,iBAAiB,MAAM,QAAQ,MAAM;AAC9E,SAAK,OAAO,KAAK;AACjB,SAAK,OAAO;AACZ,QAAI,CAAC,KAAK,OAAO;AAEb,WAAK,QAAQ;AAAA,IACjB;AAAA,EACJ;AACJ;;;ACxEI,SAAS,mBAAmB,aAAa;AACzC,MAAI,WAAW,aAAa;AACxB,WAAO;AAAA,EACX;AACA,SAAO;AAAA,IACH,OAAO;AAAA,IACP,QAAQ;AAAA,EACZ;AACJ;AAGI,IAAM,qBAAqB;AAAA,EAC3B,OAAO;AAAA,IACH,WAAW,CAAC,QAAM;AAAA,IAClB,aAAa,CAAC,QAAM;AAAA,EACxB;AAAA,EACA,QAAQ;AAAA,IACJ,WAAW,CAAC,QAAM;AAAA,IAClB,aAAa,CAAC,QAAM;AAAA,EACxB;AACJ;;;AClBA,IAAM,aAAa,OAAO,MAAM;AAChC,SAAS,KAAK,IAAI;AACd,QAAM,WAAW,OAAO;AACxB,MAAI,SAAS;AACb,SAAO,MAAI;AACP,QAAI,WAAW,UAAU;AACrB,eAAS,GAAG;AAAA,IAChB;AACA,WAAO;AAAA,EACX;AACJ;AAoBA,SAAS,OAAO,OAAO;AACnB,SAAO,OAAO,UAAU,cAAc,cAAc;AACxD;AACA,SAAS,SAAS,OAAO;AACrB,SAAO,SAAS,KAAK,KAAK,SAAS,MAAM,MAAM,CAAC,KAAK,YAAY,MAAM,MAAM;AACjF;AACA,IAAM,cAAc;AAAA,EAChB,MAAM;AAAA,EACN,aAAa;AAAA,EACb,OAAO;AAAA,EACP,SAAS,CAAC;AAAA,EACV,WAAW,CAAC;AAAA,EACZ,eAAe,CAAC;AAAA,EAChB,gBAAgB;AAAA,EAChB,aAAa;AACjB;AAGI,IAAM,gBAAgB;AAAA;AAAA;AAAA;AAAA;AAAA,EAIpB;AAAA;AAAA;AAAA;AAAA,EAGA;AAAA,EACF;AACJ;AAGI,SAAS,oBAAoB,QAAQ;AACrC,WAAS,kBAAkB,OAAO;AAC9B,UAAM,oBAAoB,IAAI,IAAI,OAAO,KAAK,KAAK,EAAE,OAAO,CAAC,MAAI,cAAc,SAAS,CAAC,CAAC,CAAC;AAC3F,QAAI,kBAAkB,OAAO,GAAG;AAC5B,YAAM,IAAI,MAAM,+CAA+C,MAAM,KAAK,iBAAiB,EAAE,KAAK,IAAI,CAAC;AAAA,IAC3G;AACA,UAAM,aAAa,cAAc,CAAC,CAAC;AACnC,UAAMC,QAAO,cAAc,CAAC,CAAC;AAC7B,aAAS,iBAAiB,MAAM;AAC5B,aAAO;AAAA,QACH,KAAK,KAAK;AAAA,QACV,MAAM,KAAK,YAAU;AACjB,gBAAMC,UAAS,MAAM,KAAK,IAAI;AAC9B,gBAAM,WAAW;AAAA,YACb,GAAG,KAAK;AAAA,YACR,KAAK;AAAA,UACT;AACA,gBAAM,UAAU,SAAS,KAAK,GAAG;AACjC,eAAK,UAAU,KAAK,GAAG,IAAI,KAAKA,QAAO,KAAK,QAAQ,QAAQ;AAC5D,iBAAOD,MAAK,OAAO;AAEnB,qBAAW,CAAC,WAAW,UAAU,KAAK,OAAO,QAAQC,QAAO,KAAK,IAAI,GAAE;AACnE,kBAAM,kBAAkB;AAAA,cACpB,GAAG;AAAA,cACH;AAAA,YACJ,EAAE,KAAK,GAAG;AAEV,YAAAD,MAAK,eAAe,IAAI,iBAAiB;AAAA,cACrC,KAAK,WAAW;AAAA,cAChB,MAAM;AAAA,cACN,KAAK;AAAA,cACL,WAAW,KAAK,UAAU,KAAK,GAAG;AAAA,YACtC,CAAC;AAAA,UACL;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AACA,aAAS,KAAK,MAAM,OAAO,CAAC,GAAG;AAC3B,YAAM,YAAY,cAAc,CAAC,CAAC;AAClC,iBAAW,CAAC,KAAK,IAAI,KAAK,OAAO,QAAQ,QAAQ,CAAC,CAAC,GAAE;AACjD,YAAI,OAAO,IAAI,GAAG;AACd,UAAAA,MAAK;AAAA,YACD,GAAG;AAAA,YACH;AAAA,UACJ,EAAE,KAAK,GAAG,CAAC,IAAI,iBAAiB;AAAA,YAC5B;AAAA,YACA,KAAK;AAAA,YACL;AAAA,YACA;AAAA,UACJ,CAAC;AACD;AAAA,QACJ;AACA,YAAI,SAAS,IAAI,GAAG;AAChB,oBAAU,GAAG,IAAI,KAAK,KAAK,KAAK,QAAQ;AAAA,YACpC,GAAG;AAAA,YACH;AAAA,UACJ,CAAC;AACD;AAAA,QACJ;AACA,YAAI,CAAC,YAAY,IAAI,GAAG;AAEpB,oBAAU,GAAG,IAAI,KAAK,MAAM;AAAA,YACxB,GAAG;AAAA,YACH;AAAA,UACJ,CAAC;AACD;AAAA,QACJ;AACA,cAAM,UAAU;AAAA,UACZ,GAAG;AAAA,UACH;AAAA,QACJ,EAAE,KAAK,GAAG;AACV,YAAI,WAAW,OAAO,GAAG;AACrB,gBAAM,IAAI,MAAM,kBAAkB,OAAO,EAAE;AAAA,QAC/C;AACA,mBAAW,OAAO,IAAI;AACtB,kBAAU,GAAG,IAAI;AAAA,MACrB;AACA,aAAO;AAAA,IACX;AACA,UAAM,SAAS,KAAK,KAAK;AACzB,UAAM,OAAO;AAAA,MACT,SAAS;AAAA,MACT,QAAQ;AAAA,MACR;AAAA,MACA,MAAAA;AAAA,MACA,GAAG;AAAA,MACH;AAAA,IACJ;AACA,UAAM,SAAS;AAAA,MACX,GAAG;AAAA,MACH;AAAA,MACA,cAAc,oBAAoB,EAAE;AAAA,QAChC;AAAA,MACJ,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AACA,SAAO;AACX;AACA,SAAS,YAAY,mBAAmB;AACpC,SAAO,OAAO,sBAAsB;AACxC;AAGI,eAAe,mBAAmB,QAAQ,MAAM;AAChD,QAAM,EAAE,KAAK,IAAI;AACjB,MAAI,YAAY,KAAK,WAAW,IAAI;AACpC,SAAM,CAAC,WAAU;AACb,UAAM,MAAM,OAAO,KAAK,KAAK,IAAI,EAAE,KAAK,CAACE,SAAM,KAAK,WAAWA,IAAG,CAAC;AAEnE,QAAI,CAAC,KAAK;AACN,aAAO;AAAA,IACX;AAGA,UAAM,aAAa,KAAK,KAAK,GAAG;AAChC,UAAM,WAAW,KAAK;AACtB,gBAAY,KAAK,WAAW,IAAI;AAAA,EACpC;AACA,SAAO;AACX;AAGI,eAAe,cAAc,MAAM;AACnC,QAAM,EAAE,MAAM,KAAK,IAAI;AACvB,QAAM,OAAO,MAAM,mBAAmB,KAAK,QAAQ,IAAI;AACvD,MAAI,CAAC,QAAQ,CAAC,YAAY,IAAI,KAAK,KAAK,KAAK,SAAS,QAAQ,CAAC,KAAK,qBAAqB;AACrF,UAAM,IAAI,UAAU;AAAA,MAChB,MAAM;AAAA,MACN,SAAS,OAAO,IAAI,wBAAwB,IAAI;AAAA,IACpD,CAAC;AAAA,EACL;AACsC,MAAI,KAAK,KAAK,SAAS,QAAQ,KAAK,uBAAuB,KAAK,KAAK,SAAS,gBAAgB;AAChI,UAAM,IAAI,UAAU;AAAA,MAChB,MAAM;AAAA,MACN,SAAS;AAAA,IACb,CAAC;AAAA,EACL;AACA,SAAO,KAAK,IAAI;AACpB;AACA,SAAS,sBAAsB;AAC3B,SAAO,SAAS,kBAAkB,QAAQ;AACtC,UAAM,EAAE,KAAK,IAAI;AACjB,WAAO,SAAS,aAAa,eAAe,MAAM;AAC9C,aAAO,qBAAqB,OAAO,EAAE,MAAM,KAAK,MAAI;AAlNhE,YAAAC;AAmNgB,cAAM,WAAW,KAAK,KAAK,GAAG;AAC9B,YAAI,KAAK,WAAW,KAAK,KAAK,CAAC,MAAM,QAAQ;AACzC,iBAAO;AAAA,QACX;AACA,cAAM,YAAY,MAAM,mBAAmB,QAAQ,QAAQ;AAC3D,YAAI,MAAM;AACV,YAAI;AACA,cAAI,CAAC,WAAW;AACZ,kBAAM,IAAI,UAAU;AAAA,cAChB,MAAM;AAAA,cACN,SAAS,+BAA+B,IAAI;AAAA,YAChD,CAAC;AAAA,UACL;AACA,gBAAM,WAAW,aAAa,IAAI,MAAM,QAAQ,QAAQ,cAAc,CAAC,IAAI;AAC3E,iBAAO,MAAM,UAAU;AAAA,YACnB,MAAM;AAAA,YACN,aAAa,YAAU,KAAK,CAAC;AAAA,YAC7B;AAAA,YACA,MAAM,UAAU,KAAK;AAAA,YACrB,QAAQ,6BAAM;AAAA,UAClB,CAAC;AAAA,QACL,SAAS,OAAO;AACZ,WAAAA,MAAA,6BAAM,YAAN,gBAAAA,IAAA,WAAgB;AAAA,YACZ;AAAA,YACA,OAAO,wBAAwB,KAAK;AAAA,YACpC,OAAO,KAAK,CAAC;AAAA,YACb,MAAM;AAAA,YACN,OAAM,uCAAW,KAAK,SAAQ;AAAA,UAClC;AACA,gBAAM;AAAA,QACV;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;AACA,SAAS,gBAAgB,YAAY;AAtPrC,MAAAA;AAuPI,QAAM,SAAS,sBAAsB,CAAC,GAAG,GAAG,WAAW,IAAI,CAAC,MAAI,EAAE,KAAK,MAAM,CAAC;AAC9E,QAAM,iBAAiB,WAAW,OAAO,CAAC,uBAAuB,eAAa;AAC1E,QAAI,WAAW,KAAK,QAAQ,kBAAkB,WAAW,KAAK,QAAQ,mBAAmB,kBAAkB;AACvG,UAAI,0BAA0B,oBAAoB,0BAA0B,WAAW,KAAK,QAAQ,gBAAgB;AAChH,cAAM,IAAI,MAAM,2CAA2C;AAAA,MAC/D;AACA,aAAO,WAAW,KAAK,QAAQ;AAAA,IACnC;AACA,WAAO;AAAA,EACX,GAAG,gBAAgB;AACnB,QAAM,cAAc,WAAW,OAAO,CAAC,MAAM,YAAU;AACnD,QAAI,QAAQ,KAAK,QAAQ,eAAe,QAAQ,KAAK,QAAQ,gBAAgB,oBAAoB;AAC7F,UAAI,SAAS,sBAAsB,SAAS,QAAQ,KAAK,QAAQ,aAAa;AAC1E,cAAM,IAAI,MAAM,uCAAuC;AAAA,MAC3D;AACA,aAAO,QAAQ,KAAK,QAAQ;AAAA,IAChC;AACA,WAAO;AAAA,EACX,GAAG,kBAAkB;AACrB,QAAM,SAAS,oBAAoB;AAAA,IAC/B;AAAA,IACA;AAAA,IACA,OAAO,WAAW,MAAM,CAAC,MAAI,EAAE,KAAK,QAAQ,KAAK;AAAA,IACjD,sBAAsB,WAAW,MAAM,CAAC,MAAI,EAAE,KAAK,QAAQ,oBAAoB;AAAA,IAC/E,UAAU,WAAW,MAAM,CAAC,MAAI,EAAE,KAAK,QAAQ,QAAQ;AAAA,IACvD,SAAQA,MAAA,WAAW,CAAC,MAAZ,gBAAAA,IAAe,KAAK,QAAQ;AAAA,EACxC,CAAC,EAAE,MAAM;AACT,SAAO;AACX;;;ACtQA,IAAI;AASJ,eAAe,OAAO;;;ACpBtB,IAAI;AAAJ,IAEA;AAAA,CACC,UAAU,QAAQ,YAAY,QAAQ,UAAU,OAAO;AAAA,CACvD,WAAW,QAAQ,iBAAiB,SAAS,eAAe,OAAO;;;ACJpE,IAAM,+BAA+B,OAAO;;;ACmE5C,IAAM,WAAW,OAAO,MAAM;;;ACrE9B,IAAM,gBAAgB,OAAO;;;ACGZ,IAAM,mBAAmB;AAGtC,SAAS,0BAA0B;AACnC,WAAS,sBAAsB,aAAa;AACxC,WAAO;AAAA,MACH,cAAc;AAAA,MACd,cAAe,uBAAuB;AAClC,cAAM,kBAAkB,kBAAkB,wBAAwB,sBAAsB,eAAe;AAAA,UACnG;AAAA,QACJ;AACA,eAAO,sBAAsB;AAAA,UACzB,GAAG;AAAA,UACH,GAAG;AAAA,QACP,CAAC;AAAA,MACL;AAAA,IACJ;AAAA,EACJ;AACA,WAAS,iBAAiB,IAAI;AAC1B,WAAO,sBAAsB;AAAA,MACzB;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;AAWI,SAAS,sBAAsB,OAAO;AACtC,QAAM,kBAAkB,eAAe,yBAAyB,MAAM;AAClE,QAAI;AACJ,UAAM,WAAW,MAAM,KAAK,YAAY;AACxC,QAAI;AACA,oBAAc,MAAM,MAAM,QAAQ;AAAA,IACtC,SAAS,OAAO;AACZ,YAAM,IAAI,UAAU;AAAA,QAChB,MAAM;AAAA,QACN;AAAA,MACJ,CAAC;AAAA,IACL;AAEA,UAAM,gBAAgB,SAAS,KAAK,KAAK,KAAK,SAAS,WAAW,IAAI;AAAA,MAClE,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,IACP,IAAI;AACJ,WAAO,KAAK,KAAK;AAAA,MACb,OAAO;AAAA,IACX,CAAC;AAAA,EACL;AACA,kBAAgB,QAAQ;AACxB,SAAO;AACX;AAGI,SAAS,uBAAuB,OAAO;AACvC,QAAM,mBAAmB,eAAe,0BAA0B,EAAE,KAAK,GAAG;AACxE,UAAM,SAAS,MAAM,KAAK;AAC1B,QAAI,CAAC,OAAO,IAAI;AAEZ,aAAO;AAAA,IACX;AACA,QAAI;AACA,YAAM,OAAO,MAAM,MAAM,OAAO,IAAI;AACpC,aAAO;AAAA,QACH,GAAG;AAAA,QACH;AAAA,MACJ;AAAA,IACJ,SAAS,OAAO;AACZ,YAAM,IAAI,UAAU;AAAA,QAChB,SAAS;AAAA,QACT,MAAM;AAAA,QACN;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACA,mBAAiB,QAAQ;AACzB,SAAO;AACX;;;ACvFA,SAASC,kBAAiB,KAAK,KAAK,OAAO;AACvC,MAAI,OAAO,KAAK;AACZ,WAAO,eAAe,KAAK,KAAK;AAAA,MAC5B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,IACd,CAAC;AAAA,EACL,OAAO;AACH,QAAI,GAAG,IAAI;AAAA,EACf;AACA,SAAO;AACX;AAC+C,IAAM,wBAAN,cAAoC,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAKnF,YAAY,QAAO;AAlBzB,QAAAC;AAmBQ,WAAMA,MAAA,OAAO,CAAC,MAAR,gBAAAA,IAAW,OAAO;AAAA,IAA6BD,kBAAiB,MAAM,UAAU,MAAM;AAC5F,SAAK,OAAO;AACZ,SAAK,SAAS;AAAA,EAClB;AACJ;;;ACrBA,SAAS,WAAW,iBAAiB;AACjC,QAAM,SAAS;AACf,MAAI,OAAO,WAAW,cAAc,OAAO,OAAO,WAAW,YAAY;AAErE,WAAO,OAAO,OAAO,KAAK,MAAM;AAAA,EACpC;AACA,MAAI,OAAO,WAAW,YAAY;AAG9B,WAAO;AAAA,EACX;AACA,MAAI,OAAO,OAAO,eAAe,YAAY;AAEzC,WAAO,OAAO,WAAW,KAAK,MAAM;AAAA,EACxC;AACA,MAAI,OAAO,OAAO,UAAU,YAAY;AAGpC,WAAO,OAAO,MAAM,KAAK,MAAM;AAAA,EACnC;AACA,MAAI,OAAO,OAAO,iBAAiB,YAAY;AAE3C,WAAO,OAAO,aAAa,KAAK,MAAM;AAAA,EAC1C;AACA,MAAI,OAAO,OAAO,WAAW,YAAY;AAErC,WAAO,OAAO,OAAO,KAAK,MAAM;AAAA,EACpC;AACA,MAAI,OAAO,OAAO,WAAW,YAAY;AAErC,WAAO,CAAC,UAAQ;AACZ,aAAO,OAAO,KAAK;AACnB,aAAO;AAAA,IACX;AAAA,EACJ;AACA,MAAI,eAAe,QAAQ;AAEvB,WAAO,OAAO,UAAQ;AAClB,YAAM,SAAS,MAAM,OAAO,WAAW,EAAE,SAAS,KAAK;AACvD,UAAI,OAAO,QAAQ;AACf,cAAM,IAAI,sBAAsB,OAAO,MAAM;AAAA,MACjD;AACA,aAAO,OAAO;AAAA,IAClB;AAAA,EACJ;AACA,QAAM,IAAI,MAAM,+BAA+B;AACnD;;;AC3CA,SAAS,iBAAiB,MAAM,MAAM;AAClC,QAAM,EAAE,cAAc,CAAC,GAAG,QAAQ,MAAM,GAAG,KAAK,IAAI;AAEpD,SAAO,cAAc;AAAA,IACjB,GAAG,sBAAsB,MAAM,IAAI;AAAA,IACnC,QAAQ;AAAA,MACJ,GAAG,KAAK;AAAA,MACR,GAAG,UAAU,CAAC;AAAA,IAClB;AAAA,IACA,aAAa;AAAA,MACT,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,IACP;AAAA,IACA,MAAM,KAAK,QAAQ,OAAO;AAAA,MACtB,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,IACP,IAAI,QAAQ,KAAK;AAAA,EACrB,CAAC;AACL;AACA,SAAS,cAAc,UAAU,CAAC,GAAG;AACjC,QAAM,OAAO;AAAA,IACT,WAAW;AAAA,IACX,QAAQ,CAAC;AAAA,IACT,aAAa,CAAC;AAAA,IACd,GAAG;AAAA,EACP;AACA,QAAM,UAAU;AAAA,IACZ;AAAA,IACA,MAAO,OAAO;AACV,YAAM,SAAS,WAAW,KAAK;AAC/B,aAAO,iBAAiB,MAAM;AAAA,QAC1B,QAAQ;AAAA,UACJ;AAAA,QACJ;AAAA,QACA,aAAa;AAAA,UACT,sBAAsB,MAAM;AAAA,QAChC;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,IACA,OAAQ,QAAQ;AACZ,YAAM,SAAS,WAAW,MAAM;AAChC,aAAO,iBAAiB,MAAM;AAAA,QAC1B;AAAA,QACA,aAAa;AAAA,UACT,uBAAuB,MAAM;AAAA,QACjC;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,IACA,KAAM,MAAM;AACR,aAAO,iBAAiB,MAAM;AAAA,QAC1B;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,IACA,IAAK,uBAAuB;AAExB,YAAM,cAAc,kBAAkB,wBAAwB,sBAAsB,eAAe;AAAA,QAC/F;AAAA,MACJ;AACA,aAAO,iBAAiB,MAAM;AAAA,QAC1B;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,IACA,gBAAiBE,UAAS;AACtB,aAAO,iBAAiB,MAAMA,SAAQ,IAAI;AAAA,IAC9C;AAAA,IACA,OAAQA,UAAS;AACb,aAAO,iBAAiB,MAAMA,SAAQ,IAAI;AAAA,IAC9C;AAAA,IACA,MAAO,UAAU;AACb,aAAO,eAAe;AAAA,QAClB,GAAG;AAAA,QACH,MAAM;AAAA,MACV,GAAG,QAAQ;AAAA,IACf;AAAA,IACA,SAAU,UAAU;AAChB,aAAO,eAAe;AAAA,QAClB,GAAG;AAAA,QACH,MAAM;AAAA,MACV,GAAG,QAAQ;AAAA,IACf;AAAA,IACA,aAAc,UAAU;AACpB,aAAO,eAAe;AAAA,QAClB,GAAG;AAAA,QACH,MAAM;AAAA,MACV,GAAG,QAAQ;AAAA,IACf;AAAA,IACA,oBAAqB,QAAQ;AACzB,aAAO,iBAAiB,MAAM;AAAA,QAC1B;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AACA,SAAO;AACX;AACA,SAAS,eAAe,QAAQ,UAAU;AACtC,QAAM,eAAe,iBAAiB,QAAQ;AAAA,IAC1C;AAAA,IACA,aAAa;AAAA,MACT,eAAe,kBAAkB,MAAM;AACnC,cAAM,OAAO,MAAM,SAAS,IAAI;AAChC,eAAO;AAAA,UACH,QAAQ;AAAA,UACR,IAAI;AAAA,UACJ;AAAA,UACA,KAAK,KAAK;AAAA,QACd;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ,CAAC;AACD,QAAM,OAAO;AAAA,IACT,GAAG,aAAa;AAAA,IAChB,MAAM,OAAO;AAAA,IACb,qBAAqB,QAAQ,aAAa,KAAK,MAAM;AAAA,IACrD,MAAM,aAAa,KAAK;AAAA,IACxB,QAAQ;AAAA,EACZ;AACA,QAAM,SAAS,sBAAsB,aAAa,IAAI;AACtD,QAAM,iBAAiB,aAAa,KAAK;AACzC,MAAI,CAAC,gBAAgB;AACjB,WAAO;AAAA,EACX;AACA,QAAM,gBAAgB,UAAU,SAAO;AACnC,WAAO,MAAM,eAAe;AAAA,MACxB;AAAA,MACA;AAAA,MACA;AAAA,IACJ,CAAC;AAAA,EACL;AACA,gBAAc,OAAO;AACrB,SAAO;AACX;AACA,IAAM,YAAY;AAAA;AAAA;AAAA,EAGhB,KAAK;AAEP,eAAe,cAAc,OAAO,MAAM,MAAM;AAC5C,MAAI;AAEA,UAAM,aAAa,KAAK,YAAY,KAAK;AACzC,UAAM,SAAS,MAAM,WAAW;AAAA,MAC5B,GAAG;AAAA,MACH,MAAM,KAAK;AAAA,MACX,OAAO,KAAK;AAAA,MACZ,KAAM,WAAW;AACb,cAAM,WAAW;AACjB,eAAO,cAAc,QAAQ,GAAG,MAAM;AAAA,UAClC,GAAG;AAAA,UACH,MAAK,qCAAU,OAAM;AAAA,YACjB,GAAG,KAAK;AAAA,YACR,GAAG,SAAS;AAAA,UAChB,IAAI,KAAK;AAAA,UACT,OAAO,YAAY,WAAW,WAAW,SAAS,QAAQ,KAAK;AAAA,UAC/D,cAAa,qCAAU,gBAAe,KAAK;AAAA,QAC/C,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AACD,WAAO;AAAA,EACX,SAAS,OAAO;AACZ,WAAO;AAAA,MACH,IAAI;AAAA,MACJ,OAAO,wBAAwB,KAAK;AAAA,MACpC,QAAQ;AAAA,IACZ;AAAA,EACJ;AACJ;AACA,SAAS,sBAAsB,MAAM;AACjC,iBAAe,UAAU,MAAM;AAE3B,QAAI,CAAC,QAAQ,EAAE,iBAAiB,OAAO;AACnC,YAAM,IAAI,MAAM,SAAS;AAAA,IAC7B;AAEA,UAAM,SAAS,MAAM,cAAc,GAAG,MAAM,IAAI;AAChD,QAAI,CAAC,QAAQ;AACT,YAAM,IAAI,UAAU;AAAA,QAChB,MAAM;AAAA,QACN,SAAS;AAAA,MACb,CAAC;AAAA,IACL;AACA,QAAI,CAAC,OAAO,IAAI;AAEZ,YAAM,OAAO;AAAA,IACjB;AACA,WAAO,OAAO;AAAA,EAClB;AACA,YAAU,OAAO;AACjB,YAAU,YAAY;AAEtB,SAAO;AACX;;;ACnMA;AAEI,IAAM,kBAAkB,OAAO,WAAW,eAAe,UAAU;AAAA,EACvE,sBAAW,YAAX,mBAAoB,QAApB,mBAA0B,iBAAgB,UAAU,CAAC,GAAC,sBAAW,YAAX,mBAAoB,QAApB,mBAA0B,sBAAqB,CAAC,GAAC,sBAAW,YAAX,mBAAoB,QAApB,mBAA0B;;;ACIjI,IAAM,cAAN,MAAM,aAAY;AAAA;AAAA;AAAA;AAAA;AAAA,EAIZ,UAAU;AACR,WAAO,IAAI,aAAY;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAIE,OAAO;AACL,WAAO,IAAI,aAAY;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA,EAIE,OAAO,MAAM;AAvBnB,QAAAC;AAwBQ,UAAM,SAAS;AAAA,MACX,GAAG;AAAA,MACH,aAAa,oBAAmB,6BAAM,gBAAe,kBAAkB;AAAA,MACvE,QAAO,6BAAM;AAAA,QACbA,MAAA,WAAW,YAAX,gBAAAA,IAAoB,IAAI,iBAAgB;AAAA,MACxC,uBAAsB,6BAAM,yBAAwB;AAAA,MACpD,iBAAgB,6BAAM,mBAAkB;AAAA,MACxC,WAAU,6BAAM,aAAY;AAAA;AAAA;AAAA;AAAA;AAAA,MAI9B,QAAQ;AAAA,IACV;AACA;AAEI,YAAM,YAAW,6BAAM,aAAY;AACnC,UAAI,CAAC,aAAY,6BAAM,0BAAyB,MAAM;AAClD,cAAM,IAAI,MAAM,kGAAkG;AAAA,MACtH;AAAA,IACJ;AACA,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA,MAIL,SAAS;AAAA;AAAA;AAAA;AAAA;AAAA,MAIT,WAAW,cAAc;AAAA,QACnB,MAAM,6BAAM;AAAA,MAChB,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA,MAIH,YAAY,wBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA,MAIpC,QAAQ,oBAAoB,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,MAIlC;AAAA;AAAA;AAAA;AAAA;AAAA,MAIA,qBAAqB,oBAAoB;AAAA,IAC3C;AAAA,EACJ;AACJ;AAII,IAAM,WAAW,IAAI,YAAY;;;AC3ErC,SAASC,kBAAiB,KAAK,KAAK,OAAO;AACvC,MAAI,OAAO,KAAK;AACZ,WAAO,eAAe,KAAK,KAAK;AAAA,MAC5B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,IACd,CAAC;AAAA,EACL,OAAO;AACH,QAAI,GAAG,IAAI;AAAA,EACf;AACA,SAAO;AACX;AACA,SAAS,kBAAkB,OAAO;AAC9B,SAAO,iBAAiB;AAAA;AAAA;AAAA;AAAA,EAGpB,iBAAiB,SAAS,MAAM,SAAS;AACjD;AACA,SAAS,oBAAoB,KAAK;AAC9B,SAAO,SAAS,GAAG,KAAK,SAAS,IAAI,OAAO,CAAC,KAAK,OAAO,IAAI,OAAO,EAAE,MAAM,MAAM,YAAY,OAAO,IAAI,OAAO,EAAE,SAAS,MAAM;AACrI;AACA,SAAS,2BAA2B,KAAK,UAAU;AAC/C,MAAI,OAAO,QAAQ,UAAU;AACzB,WAAO;AAAA,EACX;AACA,MAAI,SAAS,GAAG,KAAK,OAAO,IAAI,SAAS,MAAM,UAAU;AACrD,WAAO,IAAI,SAAS;AAAA,EACxB;AACA,SAAO;AACX;AACA,IAAM,kBAAN,MAAM,yBAAwB,MAAM;AAAA,EAChC,OAAO,KAAK,QAAQ,OAAO,CAAC,GAAG;AAC3B,UAAM,QAAQ;AACd,QAAI,kBAAkB,KAAK,GAAG;AAC1B,UAAI,KAAK,MAAM;AAEX,cAAM,OAAO;AAAA,UACT,GAAG,MAAM;AAAA,UACT,GAAG,KAAK;AAAA,QACZ;AAAA,MACJ;AACA,aAAO;AAAA,IACX;AACA,QAAI,oBAAoB,KAAK,GAAG;AAC5B,aAAO,IAAI,iBAAgB,MAAM,MAAM,SAAS;AAAA,QAC5C,GAAG;AAAA,QACH,QAAQ;AAAA,MACZ,CAAC;AAAA,IACL;AACA,WAAO,IAAI,iBAAgB,2BAA2B,OAAO,eAAe,GAAG;AAAA,MAC3E,GAAG;AAAA,MACH;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,YAAY,SAAS,MAAK;AAzD9B,QAAAC,KAAAC;AA0DQ,UAAM,QAAQ,6BAAM;AAGpB,UAAM,SAAS;AAAA,MACX;AAAA,IACJ,CAAC;AAAA;AAAA,IAEDF,kBAAiB,MAAM,SAAS,MAAM,GAAGA,kBAAiB,MAAM,SAAS,MAAM,GAAGA,kBAAiB,MAAM,QAAQ,MAAM;AAAA;AAAA;AAAA;AAAA,IAGzHA,kBAAiB,MAAM,QAAQ,MAAM;AACnC,SAAK,OAAO,6BAAM;AAClB,SAAK,QAAQ;AACb,SAAK,SAAQC,MAAA,6BAAM,WAAN,gBAAAA,IAAc;AAC3B,SAAK,QAAOC,MAAA,6BAAM,WAAN,gBAAAA,IAAc,MAAM;AAChC,SAAK,OAAO;AACZ,WAAO,eAAe,MAAM,iBAAgB,SAAS;AAAA,EACzD;AACJ;;;ACxEA,SAASC,kBAAiB,KAAK,KAAK,OAAO;AACvC,MAAI,OAAO,KAAK;AACZ,WAAO,eAAe,KAAK,KAAK;AAAA,MAC5B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,IACd,CAAC;AAAA,EACL,OAAO;AACH,QAAI,GAAG,IAAI;AAAA,EACf;AACA,SAAO;AACX;AACA,IAAM,oBAAN,MAAwB;AAAA,EACpB,SAAS,MAAM;AACX,UAAM,SAAS,YAAY;AAAA,MACvB,OAAO,KAAK;AAAA,MACZ,IAAI;AAAA,QACA,GAAG;AAAA,QACH,SAAS,KAAK,WAAW,CAAC;AAAA,QAC1B,IAAI,EAAE,KAAK;AAAA,MACf;AAAA,IACJ,CAAC;AACD,WAAO,OAAO,KAAK,MAAM,CAAC;AAAA,EAC9B;AAAA,EACA,MAAM,iBAAiB,MAAM;AACzB,QAAI;AACA,YAAM,OAAO,KAAK,SAAS,IAAI;AAC/B,YAAM,WAAW,MAAM,oBAAoB,IAAI;AAC/C,YAAM,OAAO,SAAS,OAAO;AAC7B,aAAO;AAAA,IACX,SAAS,KAAK;AACV,YAAM,gBAAgB,KAAK,GAAG;AAAA,IAClC;AAAA,EACJ;AAAA,EACA,MAAM,MAAM,OAAO,MAAM;AACrB,WAAO,KAAK,iBAAiB;AAAA,MACzB,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,SAAS,6BAAM;AAAA,MACf,QAAQ,6BAAM;AAAA,IAClB,CAAC;AAAA,EACL;AAAA,EACA,SAAS,MAAM,OAAO,MAAM;AACxB,WAAO,KAAK,iBAAiB;AAAA,MACzB,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,SAAS,6BAAM;AAAA,MACf,QAAQ,6BAAM;AAAA,IAClB,CAAC;AAAA,EACL;AAAA,EACA,aAAa,MAAM,OAAO,MAAM;AAC5B,UAAM,cAAc,KAAK,SAAS;AAAA,MAC9B,MAAM;AAAA,MACN;AAAA,MACA;AAAA,MACA,SAAS,KAAK;AAAA,MACd,QAAQ,KAAK;AAAA,IACjB,CAAC;AACD,WAAO,YAAY,UAAU;AAAA,MACzB,KAAM,UAAU;AAlE5B,YAAAC,KAAAC,KAAAC,KAAAC;AAmEgB,gBAAO,SAAS,OAAO,MAAK;AAAA,UACxB,KAAK,SACD;AACI,aAAAH,MAAA,KAAK,4BAAL,gBAAAA,IAAA,WAA+B,SAAS;AACxC;AAAA,UACJ;AAAA,UACJ,KAAK,WACD;AACI,aAAAC,MAAA,KAAK,cAAL,gBAAAA,IAAA,WAAiB;AAAA,cACb,SAAS,SAAS;AAAA,YACtB;AACA;AAAA,UACJ;AAAA,UACJ,KAAK,WACD;AACI,aAAAC,MAAA,KAAK,cAAL,gBAAAA,IAAA;AACA;AAAA,UACJ;AAAA,UACJ,KAAK;AAAA,UACL,KAAK,QACD;AACI,aAAAC,MAAA,KAAK,WAAL,gBAAAA,IAAA,WAAc,SAAS,OAAO;AAC9B;AAAA,UACJ;AAAA,QACR;AAAA,MACJ;AAAA,MACA,MAAO,KAAK;AA7FxB,YAAAH;AA8FgB,SAAAA,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AAAA,MACnB;AAAA,MACA,WAAY;AAhGxB,YAAAA;AAiGgB,SAAAA,MAAA,KAAK,eAAL,gBAAAA,IAAA;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,YAAY,MAAK;AACb,IAAAD,kBAAiB,MAAM,SAAS,MAAM;AACtC,IAAAA,kBAAiB,MAAM,WAAW,MAAM;AACxC,IAAAA,kBAAiB,MAAM,aAAa,MAAM;AAC1C,SAAK,YAAY;AACjB,SAAK,UAAU,CAAC;AAEhB,SAAK,QAAQ,KAAK,MAAM,IAAI,CAAC,SAAO,KAAK,KAAK,OAAO,CAAC;AAAA,EAC1D;AACJ;;;AC3GA,IAAM,sBAAsB,OAAO,IAAI,oBAAoB;AAmCvD,SAAS,iBAAiB,QAAQ;AAClC,SAAO,OAAO,mBAAmB;AACrC;;;ACrCI,IAAM,WAAW,CAAC,UAAU,SAAO;AACnC,SAAO,OAAO,UAAU,aAAa,MAAM,GAAG,IAAI,IAAI;AAC1D;;;ACgDA,SAAS,gBAAgB;AACrB,MAAI;AACJ,MAAI;AACJ,QAAM,UAAU,IAAI,QAAQ,CAAC,KAAK,QAAM;AACpC,cAAU;AACV,aAAS;AAAA,EACb,CAAC;AAED,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;AAKI,eAAe,WAAW,YAAY;AACtC,QAAM,MAAM,MAAM,SAAS,WAAW,GAAG;AACzC,MAAI,CAAC,WAAW,iBAAkB,QAAO;AAEzC,QAAM,SAAS,IAAI,SAAS,GAAG,IAAI,MAAM;AACzC,QAAM,mBAAmB,GAAG,MAAM;AAClC,SAAO,MAAM;AACjB;AACA,eAAe,uBAAuB,kBAAkB;AACpD,QAAM,UAAU;AAAA,IACZ,QAAQ;AAAA,IACR,MAAM,MAAM,SAAS,gBAAgB;AAAA,EACzC;AACA,SAAO,KAAK,UAAU,OAAO;AACjC;;;AClFA,SAASK,kBAAiB,KAAK,KAAK,OAAO;AACvC,MAAI,OAAO,KAAK;AACZ,WAAO,eAAe,KAAK,KAAK;AAAA,MAC5B;AAAA,MACA,YAAY;AAAA,MACZ,cAAc;AAAA,MACd,UAAU;AAAA,IACd,CAAC;AAAA,EACL,OAAO;AACH,QAAI,GAAG,IAAI;AAAA,EACf;AACA,SAAO;AACX;AAKI,SAAS,YAAY,IAAI;AACzB,QAAM,EAAE,SAAS,SAAS,OAAO,IAAI,cAAc;AACnD,KAAG,iBAAiB,QAAQ,MAAI;AAC5B,OAAG,oBAAoB,SAAS,MAAM;AACtC,YAAQ;AAAA,EACZ,CAAC;AACD,KAAG,iBAAiB,SAAS,MAAM;AACnC,SAAO;AACX;AAYI,SAAS,kBAAkB,IAAI,EAAE,YAAY,cAAc,GAAG;AAC9D,MAAI;AACJ,MAAI;AACJ,WAAS,QAAQ;AACb,kBAAc,WAAW,MAAI;AACzB,SAAG,KAAK,MAAM;AACd,oBAAc,WAAW,MAAI;AACzB,WAAG,MAAM;AAAA,MACb,GAAG,aAAa;AAAA,IACpB,GAAG,UAAU;AAAA,EACjB;AACA,WAAS,QAAQ;AACb,iBAAa,WAAW;AACxB,UAAM;AAAA,EACV;AACA,WAAS,OAAO;AACZ,iBAAa,WAAW;AACxB,UAAM;AAAA,EACV;AACA,KAAG,iBAAiB,QAAQ,KAAK;AACjC,KAAG,iBAAiB,WAAW,CAAC,EAAE,KAAK,MAAI;AACvC,iBAAa,WAAW;AACxB,UAAM;AACN,QAAI,SAAS,QAAQ;AACjB,WAAK;AAAA,IACT;AAAA,EACJ,CAAC;AACD,KAAG,iBAAiB,SAAS,MAAI;AAC7B,iBAAa,WAAW;AACxB,iBAAa,WAAW;AAAA,EAC5B,CAAC;AACL;AAII,IAAM,eAAN,MAAM,cAAa;AAAA,EACnB,IAAI,KAAK;AACL,WAAO,KAAK,aAAa,IAAI;AAAA,EACjC;AAAA,EACA,IAAI,GAAG,IAAI;AACP,SAAK,aAAa,KAAK,EAAE;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAGE,SAAS;AACP,WAAO,CAAC,CAAC,KAAK,MAAM,KAAK,GAAG,eAAe,KAAK,kBAAkB,QAAQ,CAAC,KAAK;AAAA,EACpF;AAAA;AAAA;AAAA;AAAA,EAGE,WAAW;AACT,WAAO,CAAC,CAAC,KAAK,OAAO,KAAK,GAAG,eAAe,KAAK,kBAAkB,WAAW,KAAK,GAAG,eAAe,KAAK,kBAAkB;AAAA,EAChI;AAAA,EACA,MAAM,OAAO;AACT,QAAI,KAAK,YAAa,QAAO,KAAK;AAClC,SAAK,KAAK,EAAE,cAAa;AACzB,UAAM,YAAY,WAAW,KAAK,UAAU,EAAE,KAAK,CAAC,QAAM,IAAI,KAAK,kBAAkB,GAAG,CAAC;AACzF,SAAK,cAAc,UAAU,KAAK,OAAO,OAAK;AAC1C,WAAK,KAAK;AAEV,SAAG,iBAAiB,WAAW,SAAS,EAAE,KAAK,GAAG;AAC9C,YAAI,SAAS,QAAQ;AACjB,eAAK,KAAK,MAAM;AAAA,QACpB;AAAA,MACJ,CAAC;AACD,UAAI,KAAK,cAAc,SAAS;AAC5B,0BAAkB,IAAI,KAAK,aAAa;AAAA,MAC5C;AACA,SAAG,iBAAiB,SAAS,MAAI;AAC7B,YAAI,KAAK,OAAO,IAAI;AAChB,eAAK,KAAK;AAAA,QACd;AAAA,MACJ,CAAC;AACD,YAAM,YAAY,EAAE;AACpB,UAAI,KAAK,WAAW,kBAAkB;AAClC,WAAG,KAAK,MAAM,uBAAuB,KAAK,WAAW,gBAAgB,CAAC;AAAA,MAC1E;AAAA,IACJ,CAAC;AACD,QAAI;AACA,YAAM,KAAK;AAAA,IACf,UAAE;AACE,WAAK,cAAc;AAAA,IACvB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAIE,MAAM,QAAQ;AA9HpB,QAAAC;AA+HQ,QAAI;AACA,YAAM,KAAK;AAAA,IACf,UAAE;AACE,OAAAA,MAAA,KAAK,OAAL,gBAAAA,IAAS;AAAA,IACb;AAAA,EACJ;AAAA,EACA,YAAY,MAAK;AACb,IAAAD,kBAAiB,MAAM,MAAM,EAAE,cAAa,YAAY;AACxD,IAAAA,kBAAiB,MAAM,qBAAqB,MAAM;AAClD,IAAAA,kBAAiB,MAAM,cAAc,MAAM;AAC3C,IAAAA,kBAAiB,MAAM,iBAAiB,MAAM;AAC9C,IAAAA,kBAAiB,MAAM,gBAAgB,gBAAgB,IAAI,CAAC;AAS9D,IAAAA,kBAAiB,MAAM,eAAe,IAAI;AACxC,SAAK,oBAAoB,KAAK,qBAAqB;AACnD,QAAI,CAAC,KAAK,mBAAmB;AACzB,YAAM,IAAI,MAAM,8IAA8I;AAAA,IAClK;AACA,SAAK,aAAa,KAAK;AACvB,SAAK,gBAAgB,KAAK;AAAA,EAC9B;AACJ;AACAA,kBAAiB,cAAc,gBAAgB,CAAC;;;ACtI5C,IAAM,WAAW;AAAA,EACjB,wBAAwB;AAAA,EACxB,wBAAwB;AAAA,EACxB,wBAAwB;AAAA,EACxB,wBAAwB;AAC5B;;;ACtBI,SAAS,wBAAwB,OAAO;AACxC,QAAM,OAAO,MAAM,KAAK,KAAK,GAAG;AAChC,SAAO;AAAA,IACH;AAAA,EACJ;AACJ;AAGI,SAAS,cAAc,UAAU,MAAM,gBAAgB;AAb3D,MAAAE;AAcI,QAAM,OAAO,SAAS,CAAC;AACvB,MAAI,SAAQA,MAAA,SAAS,CAAC,MAAV,gBAAAA,IAAa;AACzB,MAAI,gBAAgB;AAChB,YAAQ;AAAA,MACJ,GAAG,SAAS,CAAC;AAAA,MACb,GAAG,eAAe,cAAc,SAAY;AAAA,QACxC,QAAQ,eAAe;AAAA,MAC3B,IAAI,CAAC;AAAA,MACL,WAAW,eAAe;AAAA,IAC9B;AAAA,EACJ;AACA,SAAO;AAAA,IACH,KAAK,KAAK,GAAG;AAAA,IACb;AAAA,IACA,6BAAM;AAAA,EACV;AACJ;AAGI,eAAe,4BAA4B,eAAe,aAAa,UAAU;AACjF,QAAM,aAAa,YAAY,cAAc;AAC7C,QAAM,QAAQ,WAAW,MAAM,aAAa;AAAA,IACxC;AAAA,EACJ,CAAC;AACD,QAAM,SAAS;AAAA,IACX,MAAM,CAAC;AAAA,IACP,QAAQ;AAAA,EACZ,CAAC;AACD,QAAM,YAAY,CAAC;AACnB,mBAAiB,SAAS,eAAc;AACpC,cAAU,KAAK,KAAK;AACpB,UAAM,SAAS;AAAA,MACX,MAAM;AAAA,QACF,GAAG;AAAA,MACP;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;AAOI,SAAS,oBAAoB,MAAM,OAAO,MAAM;AAKhD,QAAM,YAAY,KAAK,QAAQ,CAAC,SAAO,KAAK,MAAM,GAAG,CAAC;AACtD,MAAI,CAAC,UAAU,CAAC,QAAQ,SAAS,QAAQ;AAIrC,WAAO,UAAU,SAAS;AAAA,MACtB;AAAA,IACJ,IAAI,CAAC;AAAA,EACT;AACA,MAAI,SAAS,cAAc,SAAS,KAAK,MAAM,eAAe,SAAS,YAAY,QAAQ;AACvF,UAAM,EAAE,QAAQ,GAAG,WAAW,IAAI,GAAG,+BAA+B,IAAI;AACxE,WAAO;AAAA,MACH;AAAA,MACA;AAAA,QACI,OAAO;AAAA,QACP,MAAM;AAAA,MACV;AAAA,IACJ;AAAA,EACJ;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,MACI,GAAG,OAAO,UAAU,eAAe,UAAU,aAAa;AAAA,QACtD;AAAA,MACJ;AAAA,MACA,GAAG,QAAQ,SAAS,SAAS;AAAA,QACzB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;AAGI,SAAS,uBAAuB,MAAM;AAEtC,QAAM,YAAY,KAAK,QAAQ,CAAC,SAAO,KAAK,MAAM,GAAG,CAAC;AACtD,SAAO,UAAU,SAAS;AAAA,IACtB;AAAA,EACJ,IAAI,CAAC;AACT;AAGI,SAAS,cAAc,aAAa;AACpC,SAAO,WAAW,WAAW,IAAI,YAAY,IAAI;AACrD;;;ACzGA,SAAS,yBAAyB,MAAM;AACpC,QAAM,EAAE,OAAO,OAAO,MAAM,UAAU,KAAK,IAAI;AAC/C,QAAM,mBAAmB,UAAU;AACnC,QAAM,UAAU,OAAO,mBAAiB;AAN5C,QAAAC;AAOQ,UAAM,aAAa;AAAA,MACf,GAAG;AAAA,MACH,MAAM;AAAA,QACF,GAAG,6BAAM;AAAA,QACT,KAAGA,MAAA,6BAAM,SAAN,gBAAAA,IAAY,kBAAiB;AAAA,UAC5B,QAAQ,eAAe;AAAA,QAC3B,IAAI;AAAA,UACA,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,SAAS,MAAM,MAAM,GAAG,cAAc,UAAU,YAAY;AAAA,MAC9D,WAAW,eAAe;AAAA,MAC1B,WAAW,eAAe;AAAA,IAC9B,CAAC,CAAC;AACF,WAAO;AAAA,EACX;AACA,SAAO,OAAO,OAAO,qBAAqB;AAAA,IACtC,GAAG;AAAA,IACH;AAAA,IACA,SAAS,mBAAmB,YAAY;AAAA,IACxC,mBAAkB,6BAAM,mBAAiB,+BAAO;AAAA,EACpD,CAAC,GAAG;AAAA,IACA,MAAM,wBAAwB;AAAA,MAC1B;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACL;;;AC9BI,SAAS,oBAAoB,MAAM;AACnC,QAAM,EAAE,QAAQ,MAAM,MAAM,UAAU,IAAI;AAC1C,QAAM,cAAc,cAAc,KAAK,WAAW;AAClD,QAAM,cAAc,uBAAuB,IAAI;AAC/C,QAAM,cAAc,YAAY,uBAAuB,YAAY,oBAAoB,WAAW,CAAC;AACnG,QAAM,2BAA0B,uCAAW,eAAc,CAAC,YAAU,QAAQ,WAAW;AACvF,QAAM,aAAa,OAAO,UAAQ;AAC9B,UAAM,SAAS,MAAM,OAAO,GAAG,cAAc;AAAA,MACzC;AAAA,MACA;AAAA,QACI;AAAA,MACJ;AAAA,IACJ,GAAG,IAAI,CAAC;AACR,WAAO;AAAA,EACX;AACA,SAAO;AAAA,IACH,GAAG;AAAA,IACH;AAAA,IACA;AAAA,IACA,aAAcC,OAAM;AAChB,YAAM,aAAa,MAAE;AAxBjC,YAAAC,KAAAC;AAwBmC,iBAAAD,MAAA,6BAAM,cAAN,gBAAAA,IAAA,WAAkB,GAAGD,aAASE,MAAA,2CAAa,cAAb,gBAAAA,IAAA,kBAAyB,GAAGF;AAAA;AACjF,aAAO,wBAAwB;AAAA,QAC3B;AAAA,QACA;AAAA,QACA,OAAM,6BAAM,UAAQ,2CAAa,SAAQ,CAAC;AAAA,MAC9C,CAAC;AAAA,IACL;AAAA,IACA,MAAM,wBAAwB;AAAA,MAC1B;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;;;AC7BI,SAAS,iBAAiB,MAAM;AAChC,QAAM,EAAE,OAAO,OAAO,MAAM,UAAU,KAAK,IAAI;AAC/C,QAAM,cAAc,cAAc,KAAK,WAAW;AAClD,QAAM,mBAAmB,UAAU;AACnC,QAAM,UAAU,OAAO,mBAAiB;AAV5C,QAAAG;AAWQ,UAAM,aAAa;AAAA,MACf,GAAG;AAAA,MACH,MAAM;AAAA,QACF,GAAG,6BAAM;AAAA,QACT,KAAGA,MAAA,6BAAM,SAAN,gBAAAA,IAAY,kBAAiB;AAAA,UAC5B,QAAQ,eAAe;AAAA,QAC3B,IAAI;AAAA,UACA,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,IACJ;AACA,UAAM,SAAS,MAAM,MAAM,GAAG,cAAc,UAAU,UAAU,CAAC;AACjE,QAAI,gBAAgB,MAAM,GAAG;AACzB,aAAO,4BAA4B,QAAQ,aAAa,QAAQ;AAAA,IACpE;AACA,WAAO;AAAA,EACX;AACA,SAAO,OAAO,OAAO,aAAa;AAAA,IAC9B,GAAG;AAAA,IACH;AAAA,IACA,SAAS,mBAAmB,YAAY;AAAA,EAC5C,CAAC,GAAG;AAAA,IACA,MAAM,wBAAwB;AAAA,MAC1B;AAAA,IACJ,CAAC;AAAA,EACL,CAAC;AACL;;;ACpCA,YAAuB;AAKnB,IAAM,0BAA0B,CAAC,SAAO;AAN5C,MAAAC;AAOI,QAAM,EAAE,WAAW,MAAM,UAAU,KAAK,IAAI;AAC5C,QAAM,SAAQA,MAAA,SAAS,CAAC,MAAV,gBAAAA,IAAa;AAC3B,QAAM,UAAU,aAAa,OAAO,CAAC,CAAC,KAAK,UAAU,UAAU;AAC/D,QAAM,aAAa,CAAC,cAAY;AAC5B,WAAO,UAAU,KAAK,KAAK,GAAG,GAAG,SAAS,QAAW,SAAS;AAAA,EAClE;AACA,SAAO;AAAA,IACH,GAAG;AAAA,IACH;AAAA,IACA,WAAW;AAAA,IACX;AAAA,IACA,MAAM,wBAAwB;AAAA,MAC1B;AAAA,IACJ,CAAC;AAAA,EACL;AACJ;AACA,SAAS,gBAAgB,MAAM;AAC3B,QAAM,UAAgB,aAAO,IAAI;AACjC,UAAQ,UAAU;AAClB,QAAM,eAAqB,aAAO,oBAAI,IAAI,CAAC,CAAC,CAAC;AAC7C,QAAM,iBAAuB,kBAAY,CAAC,QAAM;AAC5C,iBAAa,QAAQ,IAAI,GAAG;AAAA,EAChC,GAAG,CAAC,CAAC;AACL,QAAM,yBAA+B,aAAO,MAAI;AAAA,EAEhD,CAAC;AACD,QAAM,QAAc,kBAAY,MAAI;AAjCxC,QAAAA;AAmCQ,KAAAA,MAAA,uBAAuB,YAAvB,gBAAAA,IAAA;AACA,gBAAY,eAAe;AAC3B,QAAI,CAAC,KAAK,SAAS;AACf;AAAA,IACJ;AACA,UAAM,eAAe,KAAK,UAAU;AAAA,MAChC,WAAW,MAAI;AAzC3B,YAAAA,KAAAC;AA0CgB,SAAAA,OAAAD,MAAA,QAAQ,SAAQ,cAAhB,gBAAAC,IAAA,KAAAD;AACA,oBAAY,CAAC,UAAQ;AAAA,UACb,GAAG;AAAA,UACH,QAAQ;AAAA,UACR,OAAO;AAAA,QACX,EAAE;AAAA,MACV;AAAA,MACA,QAAQ,CAAC,SAAO;AAjD5B,YAAAA,KAAAC;AAkDgB,SAAAA,OAAAD,MAAA,QAAQ,SAAQ,WAAhB,gBAAAC,IAAA,KAAAD,KAAyB;AACzB,oBAAY,CAAC,UAAQ;AAAA,UACb,GAAG;AAAA,UACH,QAAQ;AAAA,UACR;AAAA,UACA,OAAO;AAAA,QACX,EAAE;AAAA,MACV;AAAA,MACA,SAAS,CAAC,UAAQ;AA1D9B,YAAAA,KAAAC;AA2DgB,SAAAA,OAAAD,MAAA,QAAQ,SAAQ,YAAhB,gBAAAC,IAAA,KAAAD,KAA0B;AAC1B,oBAAY,CAAC,UAAQ;AAAA,UACb,GAAG;AAAA,UACH,QAAQ;AAAA,UACR;AAAA,QACJ,EAAE;AAAA,MACV;AAAA,MACA,yBAAyB,CAAC,WAAS;AAC/B,oBAAY,CAAC,SAAO;AAChB,kBAAO,OAAO,OAAM;AAAA,YAChB,KAAK;AACD,qBAAO;AAAA,gBACH,GAAG;AAAA,gBACH,QAAQ;AAAA,gBACR,OAAO,OAAO;AAAA,cAClB;AAAA,YACJ,KAAK;AAED,qBAAO;AAAA,YACX,KAAK;AACD,qBAAO;AAAA,gBACH,GAAG;AAAA,gBACH,QAAQ;AAAA,gBACR,MAAM;AAAA,gBACN,OAAO;AAAA,cACX;AAAA,UACR;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ,CAAC;AACD,2BAAuB,UAAU,MAAI;AACjC,mBAAa,YAAY;AAAA,IAC7B;AAAA,EAEJ,GAAG;AAAA,IACC,QAAQ,KAAK,QAAQ;AAAA,IACrB,KAAK;AAAA,EACT,CAAC;AACD,QAAM,kBAAwB,kBAAY,MAAI;AAC1C,WAAO,KAAK,UAAU;AAAA,MAClB,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,MACR;AAAA,IACJ,IAAI;AAAA,MACA,MAAM;AAAA,MACN,OAAO;AAAA,MACP,QAAQ;AAAA,MACR;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC,KAAK;AAAA,IACL;AAAA,EACJ,CAAC;AACD,QAAM,YAAkB,aAAO,gBAAgB,CAAC;AAChD,QAAM,CAAC,OAAO,QAAQ,IAAU,eAAS,YAAY,UAAU,SAAS,cAAc,CAAC;AACvF,QAAM,QAAQ;AACd,QAAM,cAAoB,kBAAY,CAAC,aAAW;AAC9C,UAAM,OAAO,UAAU;AACvB,UAAM,OAAO,UAAU,UAAU,SAAS,IAAI;AAC9C,QAAI,eAAe;AACnB,eAAW,OAAO,aAAa,SAAQ;AACnC,UAAI,KAAK,GAAG,MAAM,KAAK,GAAG,GAAG;AACzB,uBAAe;AACf;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,cAAc;AACd,eAAS,YAAY,MAAM,cAAc,CAAC;AAAA,IAC9C;AAAA,EACJ,GAAG;AAAA,IACC;AAAA,EACJ,CAAC;AACD,EAAM,gBAAU,MAAI;AAChB,QAAI,CAAC,KAAK,SAAS;AACf;AAAA,IACJ;AACA,UAAM;AACN,WAAO,MAAI;AAzInB,UAAAA;AA0IY,OAAAA,MAAA,uBAAuB,YAAvB,gBAAAA,IAAA;AAAA,IACJ;AAAA,EACJ,GAAG;AAAA,IACC;AAAA,IACA,KAAK;AAAA,EACT,CAAC;AACD,SAAO;AACX;AACA,SAAS,YAAY,QAAQ,eAAe;AACxC,QAAM,gBAAgB,IAAI,MAAM,QAAQ;AAAA,IACpC,IAAK,QAAQ,MAAM;AACf,oBAAc,IAAI;AAClB,aAAO,OAAO,IAAI;AAAA,IACtB;AAAA,EACJ,CAAC;AACD,SAAO;AACX;;;AC7II,SAAS,uBAAuB,MAAM;AACtC,QAAM,SAAS,CAAC,SAAO;AACnB,WAAO,CAAC,MAAM,OAAO,aAAW;AAC5B,UAAI,YAAY,MAAM;AAClB,eAAO,QAAQ,QAAQ,cAAc,KAAK,GAAG,CAAC,EAAE,KAAK,CAAC,QAAM,cAAkB;AAAA,UACtE,QAAQ,KAAK;AAAA,UACb;AAAA,UACA,aAAa,YAAU;AAAA,UACvB;AAAA,UACA;AAAA,UACA,QAAQ;AAAA,QACZ,CAAC,CAAC;AAAA,MACV;AACA,YAAM,gBAAgB,KAAK,kBAAkB,oBAAoB,KAAK,SAAS,iBAAiB,KAAK,MAAM;AAC3G,aAAO,cAAc,IAAI,EAAE,MAAM,OAAO,QAAQ;AAAA,IACpD;AAAA,EACJ;AACA,SAAO,qBAAyB,CAAC,EAAE,MAAM,MAAM,MAAM,MAAI;AACrD,UAAM,OAAO;AAAA,MACT,GAAG;AAAA,IACP;AACA,UAAM,WAAW,KAAK,IAAI;AAC1B,UAAM,CAAC,MAAM,IAAI,IAAI;AACrB,UAAM,aAAa;AAAA,MACf,UAAU;AAAA,MACV,SAAS,MAAI;AACT,eAAO,oBAAoB,IAAI;AAAA,MACnC;AAAA,MACA,YAAY,MAAI;AACZ,eAAO;AAAA,UACH,GAAG;AAAA,UACH,UAAU,oBAAoB,IAAI;AAAA,QACtC;AAAA,MACJ;AAAA,MACA,cAAc,MAAI;AACd,eAAO,iBAAiB;AAAA,UACpB,OAAO;AAAA,UACP,MAAM;AAAA,UACN;AAAA,UACA,aAAa,KAAK;AAAA,UAClB,UAAU,oBAAoB,MAAM,MAAM,OAAO;AAAA,UACjD,OAAO,OAAO,OAAO;AAAA,QACzB,CAAC;AAAA,MACL;AAAA,MACA,UAAU,MAAI;AACV,eAAO,oBAAoB,MAAM,MAAM,OAAO;AAAA,MAClD;AAAA,MACA,aAAa,MAAI;AACb,eAAO;AAAA,UACH,GAAG;AAAA,UACH,UAAU,oBAAoB,MAAM,MAAM,OAAO;AAAA,QACrD;AAAA,MACJ;AAAA,MACA,sBAAsB,MAAI;AACtB,eAAO,yBAAyB;AAAA,UAC5B,OAAO;AAAA,UACP,MAAM;AAAA,UACN;AAAA,UACA,aAAa,KAAK;AAAA,UAClB,UAAU,oBAAoB,MAAM,MAAM,UAAU;AAAA,UACpD,OAAO,OAAO,OAAO;AAAA,QACzB,CAAC;AAAA,MACL;AAAA,MACA,kBAAkB,MAAI;AAClB,eAAO,oBAAoB,MAAM,MAAM,UAAU;AAAA,MACrD;AAAA,MACA,qBAAqB,MAAI;AACrB,eAAO;AAAA,UACH,GAAG;AAAA,UACH,UAAU,oBAAoB,MAAM,MAAM,UAAU;AAAA,QACxD;AAAA,MACJ;AAAA,MACA,iBAAiB,MAAI;AArFjC,YAAAE;AAsFgB,eAAO,oBAAoB;AAAA,UACvB,MAAM;AAAA,UACN;AAAA,UACA,aAAa,KAAK;AAAA,UAClB,QAAQ,OAAO,UAAU;AAAA,UACzB,YAAWA,MAAA,KAAK,cAAL,gBAAAA,IAAgB;AAAA,QAC/B,CAAC;AAAA,MACL;AAAA,MACA,aAAa,MAAI;AACb,eAAO,uBAAuB,IAAI;AAAA,MACtC;AAAA,MACA,qBAAqB,MAAI;AACrB,eAAO,wBAAwB;AAAA,UAC3B,MAAM;AAAA,UACN;AAAA,UACA,UAAU,oBAAoB,MAAM,MAAM,KAAK;AAAA,UAC/C,WAAW,OAAO,cAAc;AAAA,QACpC,CAAC;AAAA,MACL;AAAA,IACJ;AACA,WAAO,WAAW,QAAQ,EAAE;AAAA,EAChC,CAAC;AACL;;;AnCrGI,SAAS,oBAAoB;AAC7B,QAAM,oBAAwC,qBAAc,IAAI;AAChE,QAAM,cAAkC,qBAAc,IAAI;AAC1D,WAAS,aAAa,OAAO;AACzB,UAAM,QAAc,eAAQ,MAAI,uBAAuB;AAAA,MAC/C,QAAQ,MAAM;AAAA,MACd,aAAa,MAAM;AAAA,IACvB,CAAC,GAAG;AAAA,MACJ,MAAM;AAAA,MACN,MAAM;AAAA,IACV,CAAC;AACD,WAA2B,qBAAc,kBAAkB,UAAU;AAAA,MACjE,OAAO,MAAM;AAAA,IACjB,GAAuB,qBAAc,YAAY,UAAU;AAAA,MACvD;AAAA,IACJ,GAAG,MAAM,QAAQ,CAAC;AAAA,EACtB;AACA,WAAS,UAAU;AACf,UAAM,QAAc,kBAAW,WAAW;AAC1C,QAAI,CAAC,OAAO;AACR,YAAM,IAAI,MAAM,uDAAuD;AAAA,IAC3E;AACA,WAAO;AAAA,EACX;AACA,WAAS,gBAAgB;AACrB,UAAM,SAAe,kBAAW,iBAAiB;AACjD,QAAI,CAAC,QAAQ;AACT,YAAM,IAAI,MAAM,6DAA6D;AAAA,IACjF;AACA,WAAO;AAAA,EACX;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACJ;",
  "names": ["React", "_a", "observable", "_a", "lazy", "router", "key", "_a", "_define_property", "_a", "builder", "_a", "_define_property", "_a", "_b", "_define_property", "_a", "_b", "_c", "_d", "_define_property", "_a", "_a", "_a", "args", "_a", "_b", "_a", "_a", "_b", "_a"]
}
